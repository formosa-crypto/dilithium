require import AllCore List Distr DBool DList.
import StdBigop.Bigreal StdOrder.IntOrder.

require Mat.

clone include Mat.
import ZR.

lemma supp_dmatrix d m r c : 
  0 <= r => 0 <= c => 
  (m \in dmatrix d r c) <=> 
  size m = (r,c) /\ forall i j, mrange m i j => m.[i,j] \in d.
admitted.

lemma supp_dvector d v k : 
  0 <= k =>
  (v \in dvector d k) <=> 
  size v = k /\ forall i, 0 <= i < k => v.[i] \in d.
admitted.

lemma tolist_catv (v1 v2 : vector) : 
  tolist (v1 || v2) = (tolist v1) ++ (tolist v2).
admitted.

lemma size_oflist s : size (oflist s) = size s. 
proof. by rewrite /oflist /=; smt(List.size_ge0). qed.

lemma mulmxv_cat (m1 m2 : matrix) (v1 v2 : vector) : 
  cols m1 = size v1 => cols m2 = size v2 => rows m1 = rows m2 => 
  (m1 || m2) *^ (v1 || v2) = (m1 *^ v1) + (m2 *^ v2).
proof. 
move => m1_v1 m2_v2 eq_r; apply/eq_vectorP.
have -> : size ((m1 || m2) *^ (v1 || v2)) = rows m1. 
- rewrite size_mulmxv ?cols_concat_side // ?size_concat 1:/#.
  by rewrite rows_concat_side.
split => [|i Hi]; first by rewrite size_addv !size_mulmxv /#.
rewrite mulmxvE getvD ?size_mulmxv //. 
by rewrite row_concat_side // dotp_concat // !mulmxvE.
qed.


lemma subr_eq (x y z : vector) : x - z = y <=> x = y + z.
admitted.

lemma offunvN (f : int -> R) k : - offunv (f, k) = offunv (fun x => - f x, k).
proof. by apply eq_vectorP => //= i Hi; rewrite !offunvE /#. qed.
 
lemma colN (m : matrix) i : - (col m i) = col (-m) i. 
proof. rewrite /col /=. exact offunvN. qed.

lemma colmxN (v : vector) : - (colmx v) = colmx (-v).
admitted.

lemma subm_colmx (A : matrix) l : 
  cols A = l + 1 => A = (subm A 0 (rows A) 0 l || colmx (col A l)).
admitted.

lemma supp_dmatrix_full m d r c : is_full d => 
  is_full d => m \in dmatrix d r c <=> size m = (r,c).
admitted.

lemma dvector_rnd_funi (d : R distr) (v1 v2 : vector) l :
  is_funiform d => size v1 = size v2 => 
  mu1 (dvector d l) v1 = mu1 (dvector d l) v2.
admitted.

lemma dmatrix1r d k : 0 <= k => 
  dmatrix d k 1 = dmap (dvector d k) colmx. 
proof.
move => k_ge0; rewrite /dmatrix ler_maxr // dlist1 dmap_comp /(\o).
apply eq_dmap_in => v /size_dvector; rewrite ler_maxr //= => s_v.
rewrite /colmx s_v; apply/eq_matrixP => /= i j [i_bound j_bound]. 
by rewrite !offunmE /#.
qed.

op stitch r c = 
  fun (vs : vector list) => 
    offunm (fun (i j : int) => (nth witness vs j).[i], r, c).

lemma dmatrixE d r c : 
  dmatrix d r c = dmap (dlist (dvector d r) (max 0 c)) (stitch r c) by [].

lemma stitch_cat k l1 l2 (vs1 vs2 : vector list) :
  size vs1 = l1 => size vs2 = l2 => 
  stitch k (l1 + l2) (vs1 ++ vs2) = (stitch k l1 vs1 || stitch k l2 vs2).
proof.
move => s_vs1 s_vs2.
apply eq_matrixP; rewrite /stitch size_concat_side //=. 
rewrite 3?ler_maxr /=; 1..3: smt(List.size_ge0).
move => i j [i_bound j_bound]. 
rewrite concat_sideE //= ler_maxr; 1: smt(List.size_ge0).
rewrite offunmE /= ?nth_cat; 1: smt(List.size_ge0).
case (j < size vs1) => j_vs1. 
- rewrite offunmE. smt(List.size_ge0). rewrite offunm0E. smt(List.size_ge0). 
  by rewrite addr0.
- rewrite offunm0E. smt(List.size_ge0). rewrite offunmE. smt(List.size_ge0). 
  by rewrite /= s_vs1 add0r.
qed.

lemma dmatrix_add_r d k l1 l2 : 0 <= k => 0 <= l1 => 0 <= l2 =>
  dmatrix d k (l1 + l2) = 
  dmap (dmatrix d k l1 `*` dmatrix d k l2) 
       (fun mv : matrix * matrix => mv.`1 || mv.`2).
proof.
move => k_ge0 l1_ge0 l2_ge0; rewrite {1}dmatrixE ler_maxr 1:/# dlist_add //.
pose catp (p : vector list * vector list) := p.`1 ++ p.`2.
pose catm (m : matrix * matrix) := m.`1 || m.`2.
pose stichp (p : vector list * vector list) := 
  (stitch k l1 p.`1,stitch k l2 p.`2).
rewrite dmap_comp -/catp -/catm (eq_dmap_in _ _ (catm \o stichp)).
- case => vs1 vs2 /supp_dprod /= ?.
  have [? ?] : size vs1 = l1 /\ size vs2 = l2 by smt(supp_dlist).
  exact stitch_cat.
rewrite -dmap_comp -(dmap_dprod _ _ (stitch k l1) (stitch k l2)). 
have {1}-> : l1 = max 0 l1 by smt().
have {1}-> : l2 = max 0 l2 by smt().
done.
qed.

lemma dmatrixSrr d k l : 0 <= k => 0 <= l => 
  dmatrix d k (l + 1) = 
  dmap (dmatrix d k l `*` dvector d k) 
       (fun mv : matrix * vector => mv.`1 || colmx mv.`2).
proof.
move => k_ge0 l_ge0; rewrite dmatrix_add_r // dmatrix1r //.
by rewrite dmap_dprodR dmap_comp.
qed.

lemma dmatrixRSr1E d (A : matrix) k l : 
  0 <= k => 0 <= l => size A = (k,l+1) =>
  mu1 (dmatrix d k (l + 1)) A =
  mu1 (dmatrix d k l `*` dvector d k) (subm A 0 k 0 l, col A l).
proof.
move => k_ge0 l_ge0 [r_A c_A]; rewrite dmatrixSrr // dmapE /(\o) /pred1. 
apply mu_eq_support => -[B v] /supp_dprod /=.
case => /size_dmatrix /(_ _ _) //= [r_B c_B] /size_dvector s_v.
apply/eq_iff; split => [<-|[-> ->]]; last by rewrite -r_A -subm_colmx.
rewrite -r_B -c_B subm_concat_sideCl /= 1:/#.
by rewrite col_concat_sideR //= /#.
qed.

lemma supp_dmatrix_catmh d (m1 m2 : matrix) r c1 c2 : 
  m1 \in dmatrix d r c1 => m2 \in dmatrix d r c2 => 
  (m1 || m2) \in dmatrix d r (c1 + c2).
admitted.

op (**) (c : R) (v : vector) = mulvs v c.

lemma oppvN c (v : vector) : c ** -v = - (c ** v).
admitted.

lemma oppNv (c : R) (v : vector) : (- c) ** v = - (c ** v).
admitted.

lemma catvA : associative Vectors.(||).
admitted.

(* TOTHINK: this proof seems very low-level *)
lemma colmxc v c : (colmx v) *^ vectc 1 c = c ** v. 
proof. 
apply eq_vectorP; rewrite /= rows_mulmx //= size_mulvs /= => i Hi.
rewrite mulvsE // mulmxE /dotp /= lez_maxr //=.
by rewrite (Big.BAdd.big_int1 0) /= matrixcE.  
qed.

require Bigop.

abstract theory NormV.
type a.
op id : a.
op norm : R -> a.
op (+) : a -> a -> a.
op op1 : a -> a.

axiom op2A : associative (+).
axiom op2C : commutative (+).
axiom idP  : left_id id (+).

clone include Bigop with 
  type t <- a,
  op Support.idm <- id,
  op Support.(+) <- (+) 
proof* by smt(op2A op2C idP).

op pnormv v = big predT norm (tolist v).
op normv v = op1 (pnormv v).

lemma normv_cat (v1 v2 : vector) : normv (v1 || v2) = op1 (pnormv v1 + pnormv v2).
proof.
rewrite /normv /pnormv; congr. 
by rewrite tolist_catv big_cat.
qed.

end NormV. 
