require import AllCore List IntDiv.
require import PolyReduce.
require Matrix.

(* Various rounding operations. Poly and vector versions included.
 * Norm-related operations also live here for now. *)

op q : {int | prime q} as prime_q.
op n : {int | 0 < n} as gt0_n.

(* A lot of axioms can't be proven... *)
clone import PolyReduceZp as PolyReduceZq with
  op p <- q,
  op n <- n
proof ge2_p, gt0_n.
realize ge2_p by smt(prime_q gt1_prime).
realize gt0_n by exact gt0_n.

import Zp.

(* matrix dimensions *)
op k : {int | 0 < k} as gt0_k.
op l : {int | 0 < l} as gt0_l.
axiom l_k_le : l <= k.

(* Again, lots of axioms look like bad news... *)
clone import Matrix as Matrix_t with
  type ZR.t <- polyXnD1,
  op size <- k
proof ge0_size.
realize ge0_size by smt(gt0_k).

op abs_zp xp = let x = asint xp in min x (q - x).

op poly_max (p : polyXnD1) : int =
  let coeffs = mkseq (fun deg => asint p.[deg]) n in
  let coeffs' = map (fun x => if q < 2 * x then x - q else x) coeffs in
  foldr max 0 coeffs'.

op polyvec_max (vlen : int) (v : vector) =
  let polys = mkseq (fun i => v.[i]) vlen in
  let p_maxs = map poly_max polys in
  foldr max 0 p_maxs.

op poly_weight (p : polyXnD1) =
  let coeffs = mkseq (fun deg => abs_zp p.[deg]) n in
  foldr (+)%Int 0 coeffs.

op polyveck_weight (v : vector) =
  let polys = mkseq (fun i => v.[i]) k in
  let weights = map poly_weight polys in
  foldr (+)%Int 0 weights.

op mod_pm m d =
  let r = m %% d in
  if r < m %/ 2 then r else r - d.

op power2round r d =
  let r' = r %% q in
  let r0 = mod_pm r' (2 ^ d) in
  ((r' - r0) %/ (2 ^ d), r0).

op poly_power2round (p : polyXnD1) (d : int) : polyXnD1 * polyXnD1 =
  let coeffs = mkseq (fun i => asint p.[i]) n in
  let results = map (fun r => power2round r d) coeffs in
  (polyLX (map inzmod (unzip1 results)),
   polyLX (map inzmod (unzip2 results))).

op polyveck_power2round (v : vector) (d : int) : vector * vector =
  (offunv (fun i => (poly_power2round v.[i] d).`1),
   offunv (fun i => (poly_power2round v.[i] d).`2)).

op decompose r alpha =
  let r' = r %% q in
  let r0 = mod_pm r' alpha in
  if (r - r0 = q - 1)
  then
    (0, r0 - 1)
  else
    ((r' - r0) %/ alpha, r0).

op highbits r alpha = (decompose r alpha).`1.

op poly_highbits (p : polyXnD1) (alpha : int) : polyXnD1 =
  let coeffs = mkseq (fun deg => Zp.asint p.[deg]) n in
  let results = map (fun r => inzmod (highbits r alpha)) coeffs in
  polyLX results.

op polyveck_highbits (v : vector) alpha : vector =
  offunv (fun i => poly_highbits v.[i] alpha).

op lowbits r alpha = (decompose r alpha).`2.

op poly_lowbits (p : polyXnD1) (alpha : int) : polyXnD1 =
  let coeffs = mkseq (fun deg => Zp.asint p.[deg]) n in
  let results = map (fun r => inzmod (lowbits r alpha)) coeffs in
  polyLX results.

op polyveck_lowbits (v : vector) alpha : vector =
  offunv (fun i => poly_lowbits v.[i] alpha).

op makeHint z r alpha =
  let r1 = highbits r alpha in
  let v1 = highbits (r + z) alpha in
  b2i (!(r1 = v1)).

op poly_makeHint (z : polyXnD1) (r : polyXnD1) (alpha : int) : polyXnD1 =
  let zcoeffs = mkseq (fun deg => Zp.asint z.[deg]) n in
  let rcoeffs = mkseq (fun deg => Zp.asint r.[deg]) n in
  let coeffs = zip zcoeffs rcoeffs in
  polyLX (map (fun (zr : int * int) => inzmod (makeHint zr.`1 zr.`2 alpha))
      coeffs).

op polyveck_makeHint (z : vector) (r : vector) (alpha : int) : vector =
  offunv (fun i => poly_makeHint z.[i] r.[i] alpha).

op useHint h r alpha =
  let m = (q - 1) %/ alpha in
  let (r1, r0) = decompose r alpha in
  if h = 1 && 0 < r0 then
    (r1 + 1) %% m
  else if h = 1 && r0 <= 0 then
    (r1 - 1) %% m
  else
    r1.

op poly_useHint (hs rs : R) (alpha : int) =
  polyLX (mkseq (fun i => inzmod (useHint (asint hs.[i]) (asint rs.[i]) alpha)) n).

op polyveck_useHint (hv rv :vector) alpha =
  offunv (fun i => poly_useHint hv.[i] rv.[i] alpha).
