(* Formalization of the *decisional* MLWE problem. *)
(* That is, distinguishing between (A, As1 + s2) and (A, t) for random t. *)

require import AllCore Distr IntDiv.
require import PolyReduce.
require NonSquareMatrix.
require ZqRounding.

op q : {int | prime q} as prime_q.
op n : {int | 0 < n} as gt0_n.

(* A lot of axioms can't be proven... *)
clone import PolyReduceZp as PolyReduceZq with
  op p <= q,
  op n <= n
proof ge2_p, gt0_n.
realize ge2_p by smt(prime_q gt1_prime).
realize gt0_n by exact gt0_n.

op ds_entry : Zp distr.

(* matrix dimensions *)
op k : {int | 0 < k} as gt0_k.
op l : {int | 0 < l} as gt0_l.

(* Again, lots of axioms look like bad news... *)
clone import NonSquareMatrix as PolyMatrix with
  theory ZR <= PolyReduceZq.ComRing,
  op in_size <= l,
  op out_size <= k
proof ge0_in_size by smt(gt0_l),
      ge0_out_size by smt(gt0_k).

import VecOut.
type veck = vec_out.
type vecl = vec_in.

module type Adversary = {
  proc distinguish(mA: matrix, t: veck) : bool
}.

module GameL(A: Adversary) = {
  proc main() = {
    var mA, s1, s2, result;
    mA <$ dmatrix dpolyXnD1;
    s1 <$ VecIn.dvector (dpolyX ds_entry);
    s2 <$ VecOut.dvector (dpolyX ds_entry);
    result <@ A.distinguish(mA, mA *^ s1 + s2);
    return result;
  }
}.

module GameR(A: Adversary) = {
  proc main() = {
    var mA, t, result;
    mA <$ dmatrix dpolyXnD1;
    t <$ VecOut.dvector dpolyXnD1;
    result <@ A.distinguish(mA, t);
    return result;
  }
}.
