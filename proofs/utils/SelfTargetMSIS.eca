require import AllCore Distr IntDiv ZModP.
require import PolyReduce.
require NonSquareMatrix.
require PROM.
require ZqRounding.

op q : {int | prime q} as prime_q.
op n : {int | 0 < n} as gt0_n.

(* matrix dimensions *)
op k : {int | 0 < k} as gt0_k.
op l : {int | 0 < l} as gt0_l.
axiom l_k_le : l <= k.

(* In Dilithium, this is the message digest.
 * I.e. fixed-length byte array.
 *)
type M.

(* A lot of axioms can't be proven... *)
clone import PolyReduceZp as PolyReduceZq with
  op p <= q,
  op n <= n
proof ge2_p, gt0_n.
realize ge2_p by smt(prime_q gt1_prime).
realize gt0_n by exact gt0_n.

(* Again, lots of axioms look like bad news... *)
clone import NonSquareMatrix as PolyMatrix with
  theory ZR <= PolyReduceZq.ComRing,
  op in_size <= l,
  op out_size <= k
proof ge0_in_size by smt(gt0_l),
      ge0_out_size by smt(gt0_k).

clone import ZqRounding as Round with
  op q <= q,
  op n <= n,
  op k <= k,
  op l <= l,
  theory PolyReduceZq <= PolyReduceZq,
  theory PolyMatrix <= PolyMatrix.
(* TODO prove stuff *)

op [lossless uniform] dC : polyXnD1 distr.

clone import PROM.FullRO as RO with
  type in_t <- M * vec_out,
  type out_t <- polyXnD1,
  op dout <- fun _ => dC
proof *.

module type AdvRO = {
  proc get(x: M * vec_out) : polyXnD1
}.

module type Adversary (O: AdvRO) = {
  (* (mA, t) -> (m, z, c, v) where:
   * (mA, t) = A in the spec,
   * (v, z) = r in the spec. *)
  proc solve(mA : matrix, t: vec_out) : M * vec_in * R * vec_out
}.

require import List.

op gamma : int.

import VecOut.

module Game (Adv: Adversary) = {
  proc main() = {
    var mA, t;
    var m, z, c, v;
    var c';
    RO.init();
    mA <$ dmatrix dpolyXnD1;
    t <$ VecOut.dvector dpolyXnD1;
    (m, z, c, v) <@ Adv(RO).solve(mA, t);
    c' <@ RO.get((m, mA *^ z + c ** t + v));
    return polyvecl_max z <= gamma /\
      poly_max c <= gamma /\
      polyveck_max v <= gamma /\
      c = c';
  }
}.
