require import AllCore Distr IntDiv ZModP.
require import PolyReduce.
require Matrix.
require PROM.

op q : {int | prime q} as prime_q.
op n : {int | 0 < n} as gt0_n.

(* matrix dimensions *)
op k : {int | 0 < k} as gt0_k.
op l : {int | 0 < l} as gt0_l.
axiom l_k_le : l <= k.

(* In Dilithium, this is the message digest.
 * I.e. fixed-length byte array.
 *)
type M.

(* A lot of axioms can't be proven... *)
clone import PolyReduceZp as R with
  op p <- q,
  op n <- n
proof ge2_p, gt0_n.
realize ge2_p by smt(prime_q gt1_prime).
realize gt0_n by exact gt0_n.

(* Again, lots of axioms look like bad news... *)
clone import Matrix as Matrix_t with
  type ZR.t <- polyXnD1,
  op size <- k
proof ge0_size.
realize ge0_size by smt(gt0_k).

op [lossless uniform] dC : polyXnD1 distr.

clone import PROM.FullRO as RO with
  type in_t <- M * vector,
  type out_t <- polyXnD1,
  op dout <- fun _ => dC
proof *.

module type AdvRO = {
  proc get(x: M * vector) : polyXnD1
}.

module type Adversary (O: AdvRO) = {
  proc solve(mA : matrix, t: vector) : M * vector * polyXnD1 * vector
}.

module Game (Adv: Adversary) = {
  proc main() = {
    var mA, t;
    var m, z, c, v;
    var c';
    RO.init();
    mA <$ dmatrix dpolyXnD1;
    t <$ dvector dpolyXnD1;
    (m, z, c, v) <@ Adv(RO).solve(mA, t);
    c' <@ RO.get((m, mA *^ z + c ** t + v));
    return c = c';
  }
}.
