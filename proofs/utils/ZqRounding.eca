require import AllCore List IntDiv.
require import PolyReduce.
require NonSquareMatrix.
require ZModFieldExtras.
import StdOrder IntOrder.

op q : {int | prime q} as prime_q.

clone import ZModFieldExtras as ZModQ with
  op p <= q
proof prime_p by exact prime_q.

op mod_to_cmod r alpha = if r <= alpha %/ 2 then r else r - alpha.

(* centered modulo.
 * Similar to `( %% )`, but output in range (-alpha/2, alpha/2].
 * The open-closed interval is opposite of normal convention. *)
op cmod x alpha =
  let r = x %% alpha in mod_to_cmod r alpha.

op lowbits r alpha =
  if q - alpha %/ 2 <= asint r then r else
  inzmod (cmod (asint r) alpha).

op round r alpha = r - lowbits r alpha.

op rightshift r alpha = (asint r) %/ alpha.

op leftshift (r1 : int) alpha = inzmod (r1 * alpha).

op highbits r alpha = rightshift (round r alpha) alpha.

(* proofs *)

(* TODO maybe can send PR...? *)
lemma modzNDmr m n d :
  (m - n %% d) %% d = (m - n) %% d.
proof. smt(modzNm modzDmr). qed.

lemma leftshift_rightshiftK r alpha :
  alpha %| asint r =>
  leftshift (rightshift r alpha) alpha = r.
proof.
move => ?.
rewrite /leftshift /rightshift.
suff: asint r %/ alpha * alpha = asint r by smt(asintK).
by rewrite {2} (divz_eq (asint r) alpha) /#.
qed.

lemma round_is_multiple r alpha :
  2 <= alpha =>
  alpha <= q %/ 2 =>
  alpha %| asint (round r alpha).
proof.
move => ??.
rewrite /round /lowbits /=.
case (q - alpha %/ 2 <= asint r) => ? /=.
- by rewrite ZModpRing.subrr zeroE; exact (mod0z alpha).
rewrite /cmod /mod_to_cmod /=.
case (asint r %% alpha <= alpha %/ 2) => ?.
- rewrite addE oppE inzmodK modzDmr.
  have ->: (asint r %% alpha %% q = asint r %% alpha) by smt().
  rewrite pmod_small; smt(ge0_asint).
- rewrite addE oppE inzmodK modzDmr modzNDmr.
  rewrite pmod_small; first by smt(ge0_asint).
  rewrite {1} (divz_eq (asint r) alpha) /#.
qed.

lemma high_lowP r alpha :
  2 <= alpha =>
  alpha <= q %/ 2 =>
  r = leftshift (highbits r alpha) alpha + lowbits r alpha.
proof.
move => ??.
rewrite leftshift_rightshiftK; first exact round_is_multiple.
rewrite /round; by field.
qed.

lemma cmod_small x alpha :
  2 <= alpha =>
  `|cmod x alpha| <= alpha %/ 2.
proof. smt(modz_ge0 ltz_pmod). qed.

lemma lowbits_small x alpha :
  2 <= alpha =>
  alpha <= q %/ 2 =>
  `|lowbits x alpha| <= alpha %/ 2.
proof.
move => ??; rewrite /lowbits /=.
case (q - alpha %/ 2 <= asint x) => ?; first smt(gtp_asint).
by rewrite abs_zp_small; smt(cmod_small).
qed.

