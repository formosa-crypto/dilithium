require import AllCore List IntDiv.
require import PolyReduce.
require NonSquareMatrix.
require ZModFieldExtras.
import StdOrder IntOrder.

op q : {int | prime q} as prime_q.

clone import ZModFieldExtras as ZModQ with
  op p <= q
proof prime_p by exact prime_q.

op mod_to_cmod r d = if r <= d %/ 2 then r else r - d.

(* centered modulo.
 * Similar to `( %% )`, but output in range (-alpha/2, alpha/2].
 * The open-closed interval is opposite of normal convention. *)
op cmod x d =
  let r = x %% d in mod_to_cmod r d.

(* -- PROOFS -- *)

(* -- Auxiliary lemma that have nothing to do with this file -- *)

lemma crepr_eq x y :
  crepr x = crepr y <=> x = y.
proof.
smt(rg_asint asint_eq).
qed.

lemma dvdz_modzD m n d :
  d %| m =>
  d %| n =>
  d %| (m + n).
proof. smt(dvdz_modzDr). qed.

(* TODO maybe can send PR...?
 * Unsure of naming convention though. *)
lemma modzNDmr m n d :
  (m - n %% d) %% d = (m - n) %% d.
proof. smt(modzNm modzDmr). qed.

lemma asint_crepr x :
  asint x = (crepr x) %% q.
proof.
rewrite /crepr /=.
case (q %/ 2 <= asint x) => _; last by smt(modz_small rg_asint).
rewrite -modzDr.
smt(modz_small rg_asint).
qed.

(* Maybe can PR?
 * Don't know naming convention though. *)
lemma positive_multiples_lower_bound d x :
  0 < x =>
  0 < d =>
  d %| x =>
  d <= x.
proof.
smt(dvdz_eq).
qed.

(* -- Facts about centered modulo -- *)

lemma cmod_small x d :
  2 <= d =>
  `|cmod x d| <= d %/ 2.
proof. smt(modz_ge0 ltz_pmod). qed.

op cmod_to_mod r d =
  if r < 0 then r + d else r.

lemma mod_to_cmodK x d :
  0 <= x =>
  x < d =>
  cmod_to_mod (mod_to_cmod x d) d = x.
proof. smt(). qed.

lemma cmod_to_mod_injective x y d :
  -d %/ 2 < x =>
  x <= d %/ 2 =>
  -d %/ 2 < y =>
  y <= d %/ 2 =>
  cmod_to_mod x d = cmod_to_mod y d => x = y.
proof. smt(). qed.

lemma cmod_to_mod_correct x d :
  0 < d =>
  d %| (x - cmod_to_mod x d).
proof. smt(). qed.

(* Generalization of the `euclideUl` lemma to centered modulo.
 * Representative chosen from (-d %/ 2, d %/ 2] *)
lemma euclideUl_centered (x x0 d : int) :
  0 < d =>
  d %| (x - x0) =>
  -d %/ 2 < x0 =>
  x0 <= d %/ 2 =>
  x0 = cmod x d.
proof.
move => *.
rewrite /cmod /=.
apply (cmod_to_mod_injective _ _ d) => //; 1, 2: smt().
rewrite mod_to_cmodK; 1, 2: smt().
(* Fixing interface to euclideUl *)
suff: (x - (cmod_to_mod x0 d)) %/ d = x %/ d /\ (cmod_to_mod x0 d) = x %% d by smt().
apply euclideUl; last by smt().
rewrite -divz_eq.
rewrite divzK; last by smt().
have ->: x - cmod_to_mod x0 d = (x - x0) + (x0 - cmod_to_mod x0 d) by smt().
apply dvdz_modzD => //.
exact cmod_to_mod_correct.
qed.

lemma cmod_lower_bound x d :
  2 <= d =>
  2 %| d =>
  -d %/ 2 < cmod x d.
proof.
smt(modz_ge0 ltz_pmod).
qed.

(*
(* currently unused *)
lemma cmod_upper_bound x alpha :
  2 <= alpha =>
  cmod x alpha <= alpha %/ 2.
proof.
print cmod.
print mod_to_cmod.
admitted.
*)

(*
lemma cmod_to_mod_lower_bound x d :
  -d %/ 2 < x =>
  0 <= cmod_to_mod x d.
proof. smt(). qed.

lemma cmod_to_mod_upper_bound x d :
  0 < d =>
  x <= d %/ 2 =>
  cmod_to_mod x d < d.
proof. smt(). qed.
*)

(* -- Actual high-low bits rounding facts -- *)

op alpha : int.
axiom ge2_alpha : 2 <= alpha.
axiom alpha_halfq_le : alpha <= q %/ 2.
axiom even_alpha : 2 %| alpha.
axiom alpha_almost_divides_q : alpha %| (q - 1).

lemma rg_alpha : 2 <= alpha <= q %/ 2 by smt(ge2_alpha alpha_halfq_le).

op lowbits r =
  if q - alpha %/ 2 <= asint r then r else
  inzmod (cmod (asint r) alpha).

op round r = r - lowbits r.

op rightshift r = (asint r) %/ alpha.

op leftshift (r1 : int) = inzmod (r1 * alpha).

op highbits r = rightshift (round r).

lemma leftshift_rightshiftK r :
  alpha %| asint r =>
  leftshift (rightshift r) = r.
proof.
move => ?.
rewrite /leftshift /rightshift.
suff: asint r %/ alpha * alpha = asint r by smt(asintK).
by rewrite {2} (divz_eq (asint r) alpha) /#.
qed.

lemma round_is_multiple r :
  alpha %| asint (round r).
proof.
rewrite /round /lowbits /=.
case (q - alpha %/ 2 <= asint r) => ? /=.
- by rewrite ZModpRing.subrr zeroE; exact (mod0z alpha).
rewrite /cmod /mod_to_cmod /=.
case (asint r %% alpha <= alpha %/ 2) => ?.
- rewrite addE oppE inzmodK modzDmr.
  have ->: (asint r %% alpha %% q = asint r %% alpha) by smt(rg_alpha).
  rewrite pmod_small; smt(ge2_alpha ge0_asint).
- rewrite addE oppE inzmodK modzDmr modzNDmr.
  rewrite pmod_small; first by smt(ge2_alpha ge0_asint).
  rewrite {1} (divz_eq (asint r) alpha).
  smt(ge2_alpha).
qed.

lemma round_lowP r :
  r = round r + lowbits r.
proof.
rewrite /round; by field.
qed.

lemma high_lowP r :
  r = leftshift (highbits r) + lowbits r.
proof.
rewrite leftshift_rightshiftK; first exact round_is_multiple.
exact round_lowP.
qed.

lemma lowbits_small x :
  `|lowbits x| <= alpha %/ 2.
proof.
rewrite /lowbits /=.
case (q - alpha %/ 2 <= asint x) => ?; first smt(rg_alpha gtp_asint).
by rewrite abs_zp_small; smt(rg_alpha cmod_small).
qed.

lemma inzmodK_centered x :
  - q %/ 2 <= x =>
  x < q %/ 2 =>
  crepr (inzmod x) = x.
proof.
smt(rg_asint inzmodK).
qed.

lemma lowbits_id (x : zmod) :
  `|x| <= alpha %/ 2 =>
  lowbits x = x.
proof.
move => ?.
rewrite /lowbits.
case (q - alpha %/ 2 <= asint x) => [|?]; first by trivial.
apply crepr_eq.
rewrite inzmodK_centered; smt(rg_alpha rg_asint).
qed.

(*
(* Currently unused *)
lemma lowbits_normal_lower_bound (x : zmod) (alpha : int) :
  2 <= alpha =>
  alpha <= q %/ 2 =>
  2 %| alpha =>
  asint x < q - alpha =>
  -alpha %/ 2 < crepr (lowbits x alpha).
proof.
admitted.

lemma lowbits_upper_bound (x : zmod) (alpha : int) :
  2 <= alpha =>
  alpha <= q %/ 2 =>
  2 %| alpha =>
  asint x < q - alpha =>
  crepr (lowbits x alpha) <= alpha %/ 2.
proof.
admitted.
*)

(* Normal case only; no corner case *)
lemma lowbits_unique_aux (x r x0 : zmod) :
  asint x < q - alpha %/ 2 =>
  x = r + x0 =>
  alpha %| asint r =>
  asint r <= q - alpha - 1 =>
  - alpha %/ 2 < crepr x0 =>
  crepr x0 <= alpha %/ 2 =>
  lowbits x = x0.
proof.
move => *; rewrite /lowbits.
have -> /=: q - alpha %/ 2 <= asint x = false by smt().
apply crepr_eq.
rewrite inzmodK_centered; 1, 2: smt(rg_alpha rg_asint).
apply eq_sym.
apply euclideUl_centered => //; first by smt().
suff: asint x - crepr x0 = asint r by smt().
subst.
rewrite addE.
have ->: asint x0 = crepr x0 %% q by exact asint_crepr.
rewrite modzDmr.
rewrite modz_small; last by ring.
split; last by smt().
case (r = zero) => ?; first by smt(rg_asint ZModpRing.add0r).
suff: alpha <= asint r by smt().
apply positive_multiples_lower_bound => //; last by smt().
smt(rg_asint asint_eq zeroE).
qed.

lemma lowbits_unique (x r x0 : zmod) :
  x = r + x0 =>
  alpha %| asint r =>
  asint r <= q - alpha - 1 =>
  (- alpha %/ 2 < crepr x0 \/ (crepr x0 = -alpha %/ 2 /\ r = zero))=>
  crepr x0 <= alpha %/ 2 =>
  lowbits x = x0.
proof.
move => *.
(* non-corner case *)
case (asint x < q - alpha %/ 2) => ?.
- apply (lowbits_unique_aux x r x0) => //.
  smt(rg_alpha rg_asint ZModpRing.add0r).
(* corner case *)
rewrite /lowbits.
have -> /=: q - alpha %/ 2 <= asint x = true by smt().
(* suppose for the sake of contradiction that r <> 0.
 * We then have alpha <= r <= q - alpha - 1.
 * Notice we have x0 in [-alpha / 2, alpha / 2].
 * We therefore have alpha / 2 <= r + x0 <= q - alpha / 2 - 1.
 *
 * We however have x = r + x0 in [-alpha/2, 0],
 * which is disjoint from the interval above.
 *)
suff: r = zero by smt(ZModpRing.add0r).
apply contraT => ne0_r.
have ?: alpha <= asint r.
- apply positive_multiples_lower_bound; smt(rg_asint asint_eq zeroE).
suff: asint x = asint r + crepr x0 by smt().
subst.
rewrite addE.
have ->: asint x0 = crepr x0 %% q by exact asint_crepr.
by rewrite modzDmr modz_small => /#.
qed.

lemma round_unique (x r x0 : zmod) :
  x = r + x0 =>
  alpha %| asint r =>
  asint r <= q - alpha - 1 =>
  (- alpha %/ 2 < crepr x0 \/ (crepr x0 = -alpha %/ 2 /\ r = zero))=>
  crepr x0 <= alpha %/ 2 =>
  round x = r.
proof.
move => *.
rewrite /round.
suff: lowbits x = x - r.
- move => H; rewrite H; by field.
apply (lowbits_unique x r (x - r)) => //.
- by field.
- suff: x - r = x0 by trivial.
  subst; by field.
- subst.
  by have -> //: r + x0 - r = x0 by field.
qed.

lemma round_upper_bound x :
  alpha %| (q - 1) =>  
  asint (round x) <= q - alpha - 1.
proof.
move => *.
suff: asint (round x) < q - 1.
- rewrite -(divzK alpha (asint (round x))).
  + exact round_is_multiple.
  rewrite -(divzK alpha (q - 1)) //.
  rewrite -(divzK alpha (q - alpha - 1)); smt(modzDr).
suff: asint (round x) <> q - 1 by smt(rg_asint).
rewrite /round /lowbits /=.
case (q - alpha %/ 2 <= asint x) => ?.
- (* corner case always rounds to 0 *)
  have ->: x - x = zero by field.
  rewrite zeroE; smt(rg_alpha).
(* normal x's won't reach; lowbits too small and whatnot. *)
(* x < q - alpha %/ 2, and x0 <= alpha %/ 2 *)
rewrite addE oppE inzmodK.
rewrite modzDmr modzNDmr.
by rewrite modz_small; smt(ge2_alpha even_alpha rg_asint cmod_lower_bound).
qed.

lemma hide_low (x y : zmod) b1 b2 :
  `|lowbits x| <= b1 =>
  `|y| <= b2 =>
  b1 + b2 < alpha %/ 2 =>
  highbits (x + y) = highbits x.
proof.
move => *.
rewrite /highbits; congr.
rewrite (round_unique (x + y) (round x) (lowbits x + lowbits y)) //.
- rewrite {1} round_lowP.
  print lowbits_id.
  have {1} ->: y = lowbits y by smt(lowbits_id).
  by field.
- exact round_is_multiple.
- apply round_upper_bound; exact alpha_almost_divides_q.
- by left; smt(rg_alpha lowbits_id abs_zp_triangle).
- smt(rg_alpha lowbits_id abs_zp_triangle).
qed.

lemma highbits_lower_bound x :
  0 <= highbits x.
proof. smt(ge2_alpha rg_asint). qed.

lemma highbits_upper_bound x :
  highbits x <= (q - alpha - 1) %/ alpha.
proof.
move => *.
rewrite /highbits /rightshift.
suff: asint (round x) <= (q - alpha - 1) by smt(rg_alpha).
apply round_upper_bound.
exact alpha_almost_divides_q.
qed.

(* to use this lemma, the two other lemmas above would be useful *)
lemma leftshift_injective (x y : int) :
  0 <= x =>
  x <= (q - alpha - 1) %/ alpha =>
  0 <= y =>
  y <= (q - alpha - 1) %/ alpha =>
  leftshift x = leftshift y =>
  x = y.
proof.
move => ???? H.
rewrite /leftshift in H.
have H': asint (inzmod (x * alpha)) = asint (inzmod (y * alpha)) by smt().
rewrite inzmodK modz_small in H'.
- split => [|?]; first by smt(ge2_alpha).
  apply (ler_lt_trans ((q - alpha - 1) %/ alpha * alpha)); smt(ge2_alpha).
rewrite inzmodK modz_small in H'; last by smt(rg_alpha).
split => [|?]; first by smt(ge2_alpha).
by apply (ler_lt_trans ((q - alpha - 1) %/ alpha * alpha)); smt(rg_alpha).
qed.

(* -- Polynomial versions -- *)

require PolyReduce.

op n : int.

clone import PolyReduceZp as PolyReduceZq with
  type Zp <= zmod,
  op p <= q,
  op n <= n,
  theory Zp <= ZModQ.
(* TODO proof lemmas where possible *)

type int_poly = int list.

op poly_lowbits p = polyLX (mkseq (fun i => lowbits p.[i]) n).
op poly_round p = polyLX (mkseq (fun i => round p.[i]) n).
op poly_rightshift p : int_poly = mkseq (fun i => rightshift p.[i]) n.
op poly_leftshift p = polyLX (mkseq (fun i => leftshift (nth 0 p i)) n).
op poly_highbits p : int_poly = mkseq (fun i => highbits p.[i]) n.

lemma polyLXE coeffs i :
  size coeffs <= n =>
  (polyLX coeffs).[i] = nth zero coeffs i.
proof.
move => H.
rewrite /"_.[_]" /polyLX.
rewrite piK.
- by rewrite reduced_polyL //.
smt(BasePoly.polyLE).
qed.

lemma lowbits_of_zero :
  lowbits zero = zero.
proof. smt(ge2_alpha zeroE). qed.

lemma poly_lowbits_correct p i :
  (poly_lowbits p).[i] = lowbits p.[i].
proof.
rewrite /poly_lowbits polyLXE; first smt(size_mkseq ge0_n).
rewrite nth_mkseq_if /=.
smt(lt0_rcoeff gered_rcoeff lowbits_of_zero).
qed.

lemma round_of_zero :
  round zero = zero.
proof.
rewrite /round lowbits_of_zero.
by field.
qed.

lemma rightshift_of_zero :
  rightshift zero = 0.
proof.
by rewrite /rightshift zeroE.
qed.

lemma highbits_of_zero :
  highbits zero = 0.
proof.
by rewrite /highbits round_of_zero rightshift_of_zero.
qed.

lemma poly_highbits_correct p i :
  nth 0 (poly_highbits p) i = highbits p.[i].
proof.
rewrite /poly_highbits nth_mkseq_if /=.
smt(ge2_alpha highbits_of_zero lt0_rcoeff gered_rcoeff).
qed.

lemma poly_highbits_size p :
  size (poly_highbits p) = n.
proof.
rewrite /poly_highbits size_mkseq.
smt(ge0_n).
qed.

(*
lemma leftshift_of_zero alpha :
  leftshift 0 alpha = zero.
proof. smt(). qed.
*)

lemma poly_leftshift_correct p i :
  size p <= n =>
  leftshift (nth 0 p i) = (poly_leftshift p).[i].
proof.
move => ?; rewrite /poly_leftshift /=.
rewrite polyLXE; first smt(size_mkseq ge0_n).
rewrite nth_mkseq_if /=.
smt(nth_out).
qed.

(*** Used in DRing ***)
lemma poly_high_lowP p :
  poly_leftshift (poly_highbits p) + poly_lowbits p = p.
proof.
apply polyXnD1_eqP => i [??].
rewrite rcoeffD.
rewrite -poly_leftshift_correct; first smt(poly_highbits_size).
rewrite poly_highbits_correct //.
rewrite poly_lowbits_correct //.
by rewrite -high_lowP //.
qed.

require import Nat.

(* Other direction of what's been proven *)
lemma ler_bigmax' (P : 'a -> bool) F (s : 'a list) (n : nat) :
  BigMax.big P F s <= n => (forall x, x \in s => P x => F x <= n).
proof.
elim: s => [|head tail IHs le_s_n]; first by auto.
rewrite BigMax.big_cons in le_s_n.
smt(StNat.Lift.lift2E).
qed.

op inf_norm = BigMax.big predT (fun (q : zmod) => Nat.ofint `|q|).
op "`|_|" p = Nat.ofnat (inf_norm (mkseq (fun i => p.[i]) n)).

lemma ler_ofint (n : int) (m : nat) :
  0 <= n =>
  (ofint n <= m) <=> (n <= ofnat m).
proof. smt(ofintK). qed.

lemma ge0_inf_norm_p p :
  0 <= `|p|.
proof. exact StNat.valP. qed.

lemma abs_zp_zero :
  `|ZModQ.zero| = 0.
proof.
rewrite /"`|_|".
rewrite /crepr.
rewrite zeroE => /=.
smt(ge2_p).
qed.

lemma inf_norm_poly_ler p i :
  `|p.[i]| <= `|p|.
proof.
case (0 <= i /\ i < n) => ?.
- apply ler_ofint; first smt().
  apply (ler_bigmax' predT (fun (q: zmod) => Nat.ofint `|q|) (mkseq (fun i => p.[i]) n)).
  + smt().
  + smt(mkseqP).
  + smt().
- have ->: (p.[i] = ZModQ.zero) by smt(lt0_rcoeff gered_rcoeff).
  rewrite abs_zp_zero.
  exact ge0_inf_norm_p.
qed.

(*** Used in DRing ***)
lemma poly_hide_low px py b1 b2 :
  `|poly_lowbits px| <= b1 =>
  `|py| <= b2 =>
  b1 + b2 < alpha %/ 2 => poly_highbits (px + py) = poly_highbits px.
proof.
move => *.
apply (eq_from_nth 0) => [|??]; first by rewrite !poly_highbits_size.
rewrite !poly_highbits_correct rcoeffD.
apply (hide_low _ _ b1 b2) => //; last smt(inf_norm_poly_ler).
apply (ler_trans `|poly_lowbits px|) => //.
smt(poly_lowbits_correct inf_norm_poly_ler).
qed.

(* TODO lowbits small *)


(* TODO shift_inj *)
