require import AllCore List IntDiv.
require import PolyReduce.
require Matrix.

(* Various rounding operations. Poly and vector versions included.
 * Norm-related operations also live here for now. *)

op q : {int | prime q} as prime_q.
op n : {int | 0 < n} as gt0_n.

(* A lot of axioms can't be proven... *)
clone import PolyReduceZp as PolyReduceZq with
  op p <- q,
  op n <- n
proof ge2_p, gt0_n.
realize ge2_p by smt(prime_q gt1_prime).
realize gt0_n by exact gt0_n.

import Zp.

(* matrix dimensions *)
op k : {int | 0 < k} as gt0_k.
op l : {int | 0 < l} as gt0_l.
axiom l_k_le : l <= k.

(* Again, lots of axioms look like bad news... *)
clone import Matrix as Matrix_t with
  type ZR.t <- polyXnD1,
  op size <- k
proof ge0_size.
realize ge0_size by smt(gt0_k).

op abs_zp xp = let x = asint xp in min x (q - x).

op poly_max (p : R) : int =
  let coeffs = mkseq (fun deg => asint p.[deg]) n in
  let coeffs' = map (fun x => if q < 2 * x then x - q else x) coeffs in
  foldr max 0 coeffs'.

op polyvec_max (vlen : int) (v : vector) =
  let polys = mkseq (fun i => v.[i]) vlen in
  let p_maxs = map poly_max polys in
  foldr max 0 p_maxs.

op poly_weight (p : R) =
  let coeffs = mkseq (fun deg => abs_zp p.[deg]) n in
  foldr (+)%Int 0 coeffs.

op polyveck_weight (v : vector) =
  let polys = mkseq (fun i => v.[i]) k in
  let weights = map poly_weight polys in
  foldr (+)%Int 0 weights.

op mod_pm x d =
  let r = (asint x) %% d in
  if d %/ 2 < r then inzmod (r - d) else inzmod r.

op power2round (r : Zp) d =
  let r0 = mod_pm r (2 ^ d) in
  (inzmod (asint (r - r0) %/ (2 ^ d)), r0).

op poly_power2round (p : R) (d : int) : R * R =
  let coeffs = mkseq (fun i => p.[i]) n in
  let results = map (fun r => power2round r d) coeffs in
  (polyLX (unzip1 results),
   polyLX (unzip2 results)).

op polyveck_power2round (v : vector) (d : int) : vector * vector =
  (offunv (fun i => (poly_power2round v.[i] d).`1),
   offunv (fun i => (poly_power2round v.[i] d).`2)).

op decompose r alpha =
  let r0 = mod_pm r alpha in
  if (r - r0 = -one)
  then
    (zero, r0 - one)
  else
    (inzmod (asint (r - r0) %/ alpha), r0).

op highbits r alpha = (decompose r alpha).`1.

op poly_highbits (p : R) (alpha : int) : polyXnD1 =
  let coeffs = mkseq (fun deg => p.[deg]) n in
  let results = map (fun r => highbits r alpha) coeffs in
  polyLX results.

op polyveck_highbits (v : vector) alpha : vector =
  offunv (fun i => poly_highbits v.[i] alpha).

op lowbits r alpha = (decompose r alpha).`2.

op poly_lowbits (p : R) (alpha : int) : R =
  let coeffs = mkseq (fun deg => p.[deg]) n in
  let results = map (fun r => lowbits r alpha) coeffs in
  polyLX results.

op polyveck_lowbits (v : vector) alpha : vector =
  offunv (fun i => poly_lowbits v.[i] alpha).

op makeHint (z r: Zp) (alpha : int) =
  let r1 = highbits r alpha in
  let v1 = highbits (r + z) alpha in
  if r1 = v1 then zero else one.

op poly_makeHint (z r : R) (alpha : int) : R =
  let zcoeffs = mkseq (fun deg => z.[deg]) n in
  let rcoeffs = mkseq (fun deg => r.[deg]) n in
  let coeffs = zip zcoeffs rcoeffs in
  polyLX (map (fun (zr : Zp * Zp) => makeHint zr.`1 zr.`2 alpha)
      coeffs).

op polyveck_makeHint (z r : vector) (alpha : int) : vector =
  offunv (fun i => poly_makeHint z.[i] r.[i] alpha).

op useHint h r alpha =
  let m = (q - 1) %/ alpha in
  let (r1, r0) = decompose r alpha in
  if h = one && asint r0 < alpha %/ 2 then
    inzmod ((asint r1 + 1) %% m)
  else if h = one && alpha %/ 2 <= asint r0 then
    inzmod ((asint r1 - 1) %% m)
  else
    r1.

op poly_useHint (hs rs : R) (alpha : int) =
  polyLX (mkseq (fun i => useHint hs.[i] rs.[i] alpha) n).

op polyveck_useHint (hv rv : vector) alpha =
  offunv (fun i => poly_useHint hv.[i] rv.[i] alpha).

(* proofs *)

lemma abs_zp_id (x: Zp) :
  (asint x <= q %/ 2) => abs_zp x = asint x.
admitted.

lemma decompose_recompose r alpha :
  r = (highbits r alpha) * inzmod alpha + lowbits r alpha.
admitted.

lemma lowbits_bound x alpha :
  abs_zp (lowbits x alpha) <= alpha.
proof.
admitted.

lemma usehint_close (h r : Zp) (alpha : int) :
  (h = zero \/ h = one) =>
  let v1 = useHint h r alpha in
  abs_zp (r - v1 * inzmod alpha) <= alpha + 1.
proof.
move => h_val /=; case h_val => h_val.
- subst; rewrite /useHint /=.
  have -> /=: (zero = one) = false.
  + admit.
  have ->: (let (r1, _) = decompose r alpha in r1) = highbits r alpha.
  + rewrite /highbits; by case (decompose r alpha) => //.
  rewrite {1} (decompose_recompose r alpha) /=.
  have ->: highbits r alpha * inzmod alpha + lowbits r alpha -
    highbits r alpha * inzmod alpha = lowbits r alpha.
  + by ring.
  smt(lowbits_bound).
- admit.
qed.
