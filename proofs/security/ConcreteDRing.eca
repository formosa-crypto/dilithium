require import AllCore List.
require ZqRounding DRing.
require import Distr.
require import Supplementary.
require import DInterval.
require import Nat.

clone import ZqRounding as Round.
import PolyReduceZq.
import ZModQ.
require StdBigop.
import StdBigop.Bigint.BIA.
import IntDiv.

require import DistrExtras.

(* l1 norm of poly. *)
(* Not sure if it belongs here *)
op l1_norm (p : polyXnD1) = big predT ZModQ."`|_|" (mkseq (fun i => p.[i]) Round.n).
op dC a = dcond dpolyXnD1 (fun (c : polyXnD1) => `|c| <= 1 /\ l1_norm c = a).

lemma reduced_dpoly d p m :
  m <= Round.n =>
  p \in BasePoly.dpoly Round.n d =>
  reduced p.
proof.
move => *.
have ?: BasePoly.deg p <= Round.n.
- smt(BasePoly.supp_dpoly Round.gt0_n).
exact reducedP.
qed.

lemma abs_polyXN (p : polyXnD1) :
  `|-p| = `|p|.
proof.
rewrite /"`|_|"; congr.
rewrite /inf_norm.
apply BigMax.eq_big_perm_map.
apply perm_eq_refl_eq.
rewrite !map_mkseq /(\o); 1, 2: exact ge0_n.
congr; rewrite fun_ext => x /=; congr.
by rewrite -rcoeffN -abs_zpN.
qed.

lemma dpolyX_uni d :
  is_uniform d => is_uniform (dpolyX d).
proof.
move => ?.
rewrite /dpolyX.
rewrite dmap_uni_in_inj; first smt(reduced_dpoly piK).
exact BasePoly.dpoly_uni.
qed.

lemma dpolyX_supp d p :
  p \in dpolyX d <=> (forall i, 0 <= i < Round.n => p.[i] \in d).
proof.
rewrite /dpolyX.
rewrite supp_dmap.
split.
- move => [f[supp_f ?]] i rg_i; subst.
  rewrite BasePoly.supp_dpoly // in supp_f.
  case supp_f => [deg_f supp_coeff].
  by rewrite /"_.[_]" piK; smt(reducedP).
- move => *.
  exists (crepr p).
  split; last by rewrite creprK.
  apply BasePoly.supp_dpoly => //.
  split => //.
  exact deg_crepr.
qed.

lemma inf_norm_le (p : polyXnD1) a :
  0 <= a =>
  (forall i, 0 <= i < Round.n => `|p.[i]| <= a) =>
  `|p| <= a.
proof.
move => ge0_a ?; rewrite /"`|_|" /inf_norm ler_ofnat.
split; first by auto.
rewrite -ler_bigmax /=.
move => x mem_x _.
apply ler_ofint.
split => [|_]; first smt().
rewrite mkseqP in mem_x.
case mem_x => j [rg_j ?]; subst => /#.
qed.

lemma inf_norm_lt (p : polyXnD1) a :
  0 < a =>
  (forall i, 0 <= i < Round.n => `|p.[i]| < a) =>
  `|p| < a.
proof. smt(inf_norm_le). qed.

lemma inf_normXE (p : polyXnD1) a i :
  0 <= a =>
  `|p| <= a =>
  0 <= i < Round.n => `|p.[i]| <= a.
proof.
move => ge0_a H rg_i.
rewrite /"`|_|" in H.
rewrite ler_ofnat in H.
case H => [_ H].
rewrite /inf_norm /= in H.
rewrite -ler_bigmax in H.
suff: p.[i] \in mkseq (fun i => p.[i]) Round.n by smt(ler_ofint').
smt(mkseqP).
qed.

lemma inf_norm_ub (p : polyXnD1) :
  `|p| <= Round.q %/ 2.
proof.
apply inf_norm_le.
- smt(ge2_p).
- move => ?_; exact abs_zp_ub.
qed.

(**
lemma ler_ofnat' (m n : nat) :
  m <= n => ofnat m <= ofnat n.
proof. smt(). qed.
**)

(* not sure where to put this... *)
lemma abs_zp_triangle_big (xs : 'a list) f :
  `|BasePoly.BigCf.BCA.big predT f xs| <=
  big predT (fun x => `|f x|) xs.
proof.
elim xs.
- by rewrite big_nil BasePoly.BigCf.BCA.big_nil abs_zp_zero //.
move => head tail IH /=.
rewrite big_consT BasePoly.BigCf.BCA.big_consT /=.
apply (StdOrder.IntOrder.ler_trans (`|f head| + `|BasePoly.BigCf.BCA.big predT f tail|)).
- exact abs_zp_triangle.
smt().
qed.

lemma inf_l1_norm_product (x y : polyXnD1) b1 b2 :
  0 < b1 =>
  0 < b2 =>
  `|x| <= b1 =>
   l1_norm y <= b2 =>
  `|x * y| <= b1 * b2.
proof.
move => gt0_b1 gt0_b2 inf_norm_x_ub l1_norm_y_ub.

(* clean up inf_norm hypothesis *)
rewrite ler_ofnat in inf_norm_x_ub.
case inf_norm_x_ub => _ inf_norm_x_ub.
rewrite -ler_bigmax /= in inf_norm_x_ub.
have ?: forall z, z \in mkseq (fun i => x.[i]) Round.n => `|z| <= b1.
- smt(ler_ofint').
clear inf_norm_x_ub.

(* from poly to entry-wise ler *)
apply ler_ofnat.
split; first by smt().
apply ler_bigmax => z.
rewrite mkseqP.
move => [i [rg_i ?]] _ /=; subst.
apply ler_ofint.
split => [|_]; first smt().

(* rewriting poly product *)
rewrite PolyReduceZq.ComRing.mulrC.
rewrite rcoeffM //.

apply (StdOrder.IntOrder.ler_trans
  (bigi predT
    (fun j => `| y.[j] * x.[i - j] - y.[j] * x.[Round.n + i - j] |) 0 Round.n)).
- exact abs_zp_triangle_big.

apply (StdOrder.IntOrder.ler_trans
  (bigi predT (fun j => `| y.[j] | * b1) 0 Round.n)).
- apply StdBigop.Bigint.ler_sum_seq => /= j rg_j _.
  rewrite mem_range in rg_j.
  case (i < j) => ?.
  + have ->: x.[i - j] = ZModQ.zero.
    - by rewrite lt0_rcoeff //; first smt().
    rewrite ZModpRing.mulr0 ZModpRing.sub0r -abs_zpN.
    apply (StdOrder.IntOrder.ler_trans (`|y.[j]| * `|x.[Round.n + i - j]|)).
    - exact abs_zp_prod.
    suff: `|x.[Round.n + i - j]| <= b1.
    - by have /#: 0 <= `|y.[j]| by smt(ge0_abs_zp).
    suff: x.[Round.n + i - j] \in mkseq (fun i => x.[i]) Round.n by move => ? /#.
    by apply mkseqP; exists (Round.n + i - j) => /#.
  + have ->: x.[Round.n + i - j] = ZModQ.zero.
    - by rewrite gered_rcoeff // /#.
    rewrite ZModpRing.mulr0 ZModpRing.subr0.
    apply (StdOrder.IntOrder.ler_trans (`|y.[j]| * `|x.[i - j]|)); first exact abs_zp_prod.
    suff: `|x.[i - j]| <= b1.
    - by have /#: 0 <= `|y.[j]| by smt(ge0_abs_zp).
    suff: x.[i - j] \in mkseq (fun i => x.[i]) Round.n by move => ? /#.
    by apply mkseqP; exists (i - j) => /#.
rewrite -big_distrl //; first smt().

suff: bigi predT (fun (a : int) => `|y.[a]|) 0 Round.n = l1_norm y by smt().
rewrite /l1_norm /mkseq big_mapT.
by congr => /#.
qed.

op dpoly_openball i =
  if 1 <= i <= Round.q %/ 2 then dpolyX (dopenball_zp i) else dpolyXnD1.

op dpoly_ball i =
  if 0 <= i < Round.q %/ 2 then dpolyX (dball_zp i) else dpolyXnD1.

lemma poly_leftshift_imE alpha (xs : int list) (x : int) :
  2 <= alpha =>
  x \in xs =>
  image (poly_highbits alpha) xs =>
  image (highbits alpha) x.
proof.
move => ge2_alpha in_x im_xs.
case im_xs => [y im_y].
rewrite eq_sym in im_y; subst.
rewrite /poly_highbits mkseqP in in_x.
case in_x => [i [rg_i ?]]; subst.
by exists (y.[i]).
qed.

(* Makes a valid challenge *)
op make_valid_challenge a =
  polyLX (nseq a one).

lemma make_valid_challenge_infty_norm a :
  0 <= a <= Round.n =>
  `|make_valid_challenge a| <= 1.
proof.
move => rg_a.
rewrite /make_valid_challenge /"`|_|".
rewrite /inf_norm ler_ofnat /= -ler_bigmax => x supp_x _.
rewrite mkseqP in supp_x.
case supp_x => i [rg_i ?]; subst => /=.
apply ler_ofint.
split => [|_]; first exact ge0_abs_zp.
rewrite polyLXE; first smt(size_nseq).
rewrite nth_nseq_if.
case (0 <= i && i < a) => /= _.
- by rewrite abs_zp_one //.
- by rewrite abs_zp_zero //.
qed.

lemma make_valid_challenge_1norm a :
  0 <= a <= Round.n =>
  l1_norm (make_valid_challenge a) = a.
proof.
move => rg_a; rewrite /l1_norm /make_valid_challenge.
have ->: (mkseq (fun i => (polyLX (nseq a one)).[i]) Round.n =
          mkseq (fun i => nth ZModQ.zero (nseq a one) i) Round.n).
- apply eq_in_mkseq => i rg_i /=.
  apply polyLXE.
  rewrite size_nseq; smt().
have ->: ((fun i => nth ZModQ.zero (nseq a one) i) =
           fun i => if 0 <= i < a then one else ZModQ.zero).
- by rewrite fun_ext => i; rewrite nth_nseq_if //.
have ->: mkseq (fun (i : int) => if 0 <= i && i < a then one else ZModQ.zero) Round.n
       = nseq a one ++ nseq (Round.n - a) ZModQ.zero.
- apply (eq_from_nth ZModQ.zero).
  + by rewrite size_cat size_mkseq !size_nseq => /#.
  move => i rg_i.
  rewrite size_mkseq in rg_i.
  rewrite nth_mkseq_if /=.
  have -> /=: ((0 <= i && i < Round.n) = true) by smt().
  rewrite nth_cat /=.
  rewrite size_nseq; smt(nth_nseq).
rewrite big_cat !big_nseq.
rewrite abs_zp_zero abs_zp_one.
rewrite -!AddMonoid.iteropE.
rewrite -!StdOrder.IntOrder.Domain.intmulpE; 1,2: smt().
by rewrite !intmulz.
qed.

clone DRing as DR with
  op q <= q,
  op n <= Round.n,
  type Rq <= PolyReduceZq.polyXnD1,
  theory RqRing <= PolyReduceZq.ComRing,
  op cnorm <= Round."`|_|",
  op dRq <= dpolyXnD1,
  op dRq_ <= dpoly_ball,
  op dRq_open <= dpoly_openball,
  op dC <= dC,
  op l1_norm <= l1_norm,
  type Flex.high <= int list,
  op Flex.highBits <= poly_highbits,
  op Flex.shift <= poly_leftshift,
  op Flex.lowBits <= poly_lowbits
proof *.
realize prime_q by exact prime_q.
realize gt0_n by exact gt0_n.
realize dRq_ll by exact dpolyXnD1_ll.
realize supp_dC by smt(dcond_supp dpolyXnD1_fu).
realize dRq_uni by exact dpolyXnD1_uni.
realize dRq_fu by exact dpolyXnD1_fu.
realize dRq__ll.
move => i; rewrite /dpoly_ball.
case (0 <= i < Round.q %/ 2) => /= ?; last exact dpolyXnD1_ll.
by rewrite dpolyX_ll dball_zp_ll /#.
qed.
realize dRq__uni.
move => i; rewrite /dpoly_ball.
case (0 <= i < Round.q %/ 2) => /= ?; last exact dpolyXnD1_uni.
by rewrite dpolyX_uni dball_zp_uni /#.
qed.
realize supp_dRq.
move => p a ?; rewrite /dpoly_ball.
have -> /=: (0 <= a) = true by smt().
case (a < Round.q %/ 2) => /= ?; last smt(dpolyXnD1_fu inf_norm_ub).
rewrite dpolyX_supp.
split => H.
- apply inf_norm_le; first smt().
  smt(dball_zp_supp).
- move => i rg_i.
  rewrite dball_zp_supp //.
  smt(inf_normXE).
qed.
realize dC_ll.
move => i rg_i.
apply dcond_ll.
apply witness_support => /=.
exists (make_valid_challenge i).
split; last by exact dpolyXnD1_fu.
split; first by exact make_valid_challenge_infty_norm.
exact make_valid_challenge_1norm.
qed.
realize dC_uni.
move => i.
apply uni_dcond.
exact dpolyXnD1_uni.
qed.
realize cnorm_ge0 by exact ge0_inf_norm_p.
realize cnormN by exact abs_polyXN.
realize Flex.high_lowP by exact poly_high_lowP.
realize Flex.hide_low by smt(poly_hide_low).
realize Flex.lowbit_small by exact poly_lowbit_small.
realize Flex.shift_inj.
move => alpha rg_alpha even_alpha alpha_almost_divides_q xs ys im_x im_y sx_sy_eq.
apply (poly_leftshift_inj alpha xs ys) => //.
- smt(poly_highbits_size).
- smt(poly_highbits_size).
- smt(poly_leftshift_imE).
- smt(poly_leftshift_imE).
qed.
realize dRq_open_ll.
move => i; rewrite /dpoly_openball.
case (1 <= i <= Round.q %/ 2) => /= ?; last exact dpolyXnD1_ll.
by rewrite dpolyX_ll dball_zp_ll /#.
qed.
realize dRq_open_uni.
move => i; rewrite /dpoly_openball.
case (1 <= i <= Round.q %/ 2) => /= ?; last exact dpolyXnD1_uni.
by rewrite dpolyX_uni dball_zp_uni /#.
qed.
realize supp_dRq_open.
move => p a ?; rewrite /dpoly_openball.
have -> /=: (1 <= a) = true by smt().
case (a <= Round.q %/ 2) => /= ?; last smt(dpolyXnD1_fu inf_norm_ub).
rewrite dpolyX_supp.
split => H.
- apply inf_norm_lt; first smt().
  smt(dball_zp_supp).
- move => i rg_i.
  rewrite dball_zp_supp //; 1, 2: smt().
  by rewrite inf_normXE => /#.
qed.
