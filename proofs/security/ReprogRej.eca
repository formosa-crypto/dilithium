require import AllCore Distr DBool PROM List.
import Biased.
require import Dexcepted.
require import Dfilter.
require import Real RealSeries.
require import CoreMap.
import SmtMap.
import Biased.
require ReprogOnlyRej.

require import DistrExtras.

type X, Y, Z, K.

op [lossless] dXYZ_acc (k : K) : (X * Y * Z) distr.
op [lossless] dXY_rej (k : K) : (X * Y) distr.
op [lossless uniform] dY : Y distr.
op alpha : real.

op dXr k = dfst (dXY_rej k).
axiom dX_pmax k :
  p_max (dXr k) <= alpha.

op qh, qr : int.
axiom qh_gt0 : 0 < qh.
axiom qr_gt0 : 0 < qr.

clone import ReprogOnlyRej as OnlyRej with
  type X <- X,
  type Y <- Y,
  type M <- K,
  op dY <- dY,
  op dXY_rej <- dXY_rej,
  op qh <- qh,
  op qr <- qr,
  op alpha <- alpha
proof *.
realize dXY_rej_ll by apply dXY_rej_ll.
realize dY_ll by apply dY_ll.
realize dY_uni by apply dY_uni.
realize qh_gt0 by apply qh_gt0.
realize qr_gt0 by apply qr_gt0.
realize dX_pmax by apply dX_pmax.

import FullRO.

module type Oracle = {
  proc h(x: X) : Y
  proc reprog_acc(k: K) : X * Y * Z
  proc reprog_rej(k: K) : unit
}.

module type Oracle_i = {
  include Oracle
  proc init() : unit
}.

(*
 * ReprogRej: Basic RO games that we plan to reduce to.
 * Adversary can make three possible queries, as discussed on the notes.
 * Only third query (reprog_rej) is different between GameA and GameB.
 *
 * The games are indistinguishable in ROM.
 * I hope same is true in QROM.
 *)

module OLeft : Oracle_i = {

  proc init() = {
    RO.init();
  }

  proc h(x) = {
    var y;
    y <@ RO.get(x);
    return y;
  }

  proc reprog_acc(m) = {
    var x, y, z;
    (x, y, z) <$ dXYZ_acc m;
    RO.set(x, y);
    return (x, y, z);
  }

  proc reprog_rej(m) = {
    var x, y;
    (x, y) <$ dXY_rej m;
    (* reprog *)
    RO.set(x, y);
    (* no return *)
  }
}.

module ORight : Oracle_i = {
  include var OLeft [init, h, reprog_acc]
  proc reprog_rej(k:K) = { }
}.

module type Adversary(O: Oracle) = {
  proc distinguish() : bool
}.

module Game (O: Oracle_i) (Adv: Adversary) = {
  proc main() = {
    var b;
    O.init();
    b <@ Adv(O).distinguish();
    return b;
  }
}.

module Count (O: Oracle) : Oracle = {
  var countR, countH : int
  proc reprog_acc(x) = {
    var y;
    y <@ O.reprog_acc(x);
    return y;
  }
  proc h(x) = {
    var y;
    countH <- countH + 1;
    y <@ O.h(x);
    return y;
  }
  proc reprog_rej(x) = {
    var y;
    countR <- countR + 1;
    y <@ O.reprog_rej(x);
    return y;
  }
}.

section.

module OLeft_rec : Oracle_i = {
  include var OLeft [reprog_acc]

  var bad : bool
  var rej_lst : X list

  proc init() = {
    RO.init();
    bad <- false;
    rej_lst <- [];
  }

  proc h(x) = {
    var y;
    if(x \in rej_lst)
      bad <- true;
    y <@ RO.get(x);
    return y;
  }

  proc reprog_rej(m) = {
    var x, y;
    (x, y) <$ dXY_rej m;
    (* reprog *)
    RO.set(x, y);
    rej_lst <- x :: rej_lst;
    (* no return *)
  }
}.

module ORight_rec : Oracle_i = {
  include var OLeft_rec[init, h, reprog_acc]

  proc reprog_rej(m: K) = {
    var x, y;
    (x, y) <$ dXY_rej m;
    rej_lst <- x :: rej_lst;
  }
}.


module (ReduceO(O: OnlyRej.Oracle) : Oracle) = {
  var overlay : (X, Y) fmap

  proc init() = {
    overlay <- empty;
  }

  proc h(x) = {
    var y;
    y <@ O.h(x);
    if (x \in overlay) {
      y <- oget overlay.[x];
    }
    return y;
  }

  proc reprog_rej(m) = {
    var r;
    r <@ O.reprog_rej(m);
    return r;
  }

  proc reprog_acc(m) = {
    var x, y, z;
    (x, y, z) <$ dXYZ_acc m;
    overlay.[x] <- y;
    return (x, y, z);
  }  
}.

declare module A <: Adversary {-OLeft_rec, -RO, -Count,
  -RejGuessing.SGO, -RejGuessing.Count, -RejGuessing.SO, -RejGuessing.SCount, -OnlyRej.Count, -OnlyRej.OMain, -ReduceO}.

declare axiom A_ll : (forall (O <: Oracle{-A}),
  islossless O.h =>
  islossless O.reprog_acc =>
  islossless O.reprog_rej =>
  islossless A(O).distinguish).

declare axiom A_bound : forall (O <: Oracle{-A, -Count}), 
  hoare [ A(Count(O)).distinguish : Count.countR = 0 /\ Count.countH = 0 ==> 
                                    Count.countR <= qr /\ Count.countH <= qh ].

lemma ReprogRejRecBound &m :
  `| Pr[Game(OLeft_rec, A).main() @ &m : res]
   - Pr[Game(ORight_rec, A).main() @ &m : res] |
  <= Pr[Game(OLeft_rec, A).main() @ &m : OLeft_rec.bad].
proof.
suff:
  `| Pr[Game(ORight_rec, A).main() @ &m : res]
   - Pr[Game(OLeft_rec, A).main() @ &m : res] |
  <= Pr[Game(OLeft_rec, A).main() @ &m : OLeft_rec.bad] by smt().
byequiv (_: ={glob A, RO.m, OLeft_rec.bad, OLeft_rec.rej_lst} ==>
  ={OLeft_rec.bad} /\ (!OLeft_rec.bad{1} => ={res})) :
  OLeft_rec.bad; 2, 3: smt().
proc.
seq 1 1: (#pre /\ !OLeft_rec.bad{1} /\ !OLeft_rec.bad{2}).
- inline OLeft_rec.init RO.init; by auto.
call (_: OLeft_rec.bad,
     ={OLeft_rec.bad, OLeft_rec.rej_lst} /\
     (forall x, (!(x \in OLeft_rec.rej_lst{1}) => RO.m{1}.[x] = RO.m{2}.[x])),
     ={OLeft_rec.bad}); 1: by apply A_ll.
(* H *)
- proc; inline RO.get; auto => />.
  smt(get_setE get_set_sameE).
- move => *; proc.
  inline RO.get; auto => />.
  smt(dY_ll).
- move => *; proc.
  inline RO.get; auto => />.
  smt(dY_ll).
(* acc *)
- proc. inline RO.set; auto => />.
  smt(get_setE get_set_sameE).
- move => *; proc.
  inline RO.set; auto => />.
  smt(dXYZ_acc_ll).
- move => *; proc.
  inline RO.set; auto => />.
  smt(dXYZ_acc_ll).
(* rej *)
- proc; inline RO.set; auto => />.
  smt(get_setE get_set_sameE).
- move => *; proc; auto => />.
  smt(dXY_rej_ll).
- move => *; proc.
  inline RO.set; auto => />.
  smt(dXY_rej_ll).
(* after call *)
- skip => />; smt().
qed.

module (Reduction : OnlyRej.Adversary)(O: OnlyRej.Oracle) = {
   proc main () = {
     ReduceO.overlay <- empty;
     A(ReduceO(O)).distinguish();
   }
}.

equiv reduce_to_onlyrej :
  Game(OLeft_rec, A).main ~ OnlyRej.Game(Reduction).main :
  ={glob A} ==> OLeft_rec.bad{1} = res{2}.
proof.
proc; inline *; sp.
(* Mmmmm 11 subgoals *)
call(_: OnlyRej.OMain.win,
  OLeft_rec.bad{1} = OnlyRej.OMain.win{2} /\
  (!OLeft_rec.bad{1} =>
  (OLeft_rec.rej_lst{1} = OnlyRej.OMain.rej_lst{2} /\
  (forall x, ! x \in OLeft_rec.rej_lst{1} =>
  RO.m.[x]{1} = if x \in ReduceO.overlay{2} then ReduceO.overlay{2}.[x] else RO.m.[x]{2}))),
  OLeft_rec.bad{1} = OnlyRej.OMain.win{2}).
(* lossless stuff *)
- admit.
(* H *)
- proc.
  inline OMain.h.
  seq 0 1: (#pre /\ x0{2} = x{2}); first by auto.
  if; first by auto => />.
  + (* bad *)
    by inline RO.get; auto => />.
  + (* not bad *)
    inline RO.get.
    auto => />.
    smt(get_setE get_set_sameE).
- move => &2 win.
  proc.
  inline RO.get.
  auto => />.
  smt(dY_ll).
- move => &1.
  proc.
  inline OMain.h RO.get.
  auto => />.
  smt(dY_ll).
(* acc *)
- proc; inline *.
  auto => />.
  smt(get_setE get_set_sameE).
- move => &2 win.
  proc; inline *.
  auto => /> ?.
  exact dXYZ_acc_ll.
- move => &1.
  proc.
  auto => /> ??.
  exact dXYZ_acc_ll.
(* rej *)
- proc; inline *.
  auto => />.
  smt(get_setE get_set_sameE).
- move => &2 win.
  proc; inline *.
  auto => /> ?.
  exact dXY_rej_ll.
- move => &1.
  proc; inline *.
  auto => /> ??.
  exact dXY_rej_ll.
(* overall *)
by skip => /#.
qed.

lemma bad_bound &m :
  Pr[Game(OLeft_rec, A).main() @ &m : OLeft_rec.bad] <= qr%r * qh%r * alpha.
proof.
have ->: Pr[Game(OLeft_rec, A).main() @ &m : OLeft_rec.bad] =
         Pr[OnlyRej.Game(Reduction).main() @ &m : res].
- byequiv; 2, 3: smt().
  by conseq reduce_to_onlyrej => /#.
apply (OnlyRej.win_bound Reduction).
(* TODO Reduction query bound... *)
admitted.

lemma ReprogRejBound &m :
  `| Pr[Game(OLeft, A).main() @ &m : res]
   - Pr[Game(ORight, A).main() @ &m : res] |
  <= qh%r * qr%r * alpha.
proof.

admitted.

end section.

print ReprogRejBound.
