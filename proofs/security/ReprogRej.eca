require import AllCore Distr DBool PROM List.
import Biased.
require import Dexcepted.
require import Dfilter.
require import Real RealSeries.
import SmtMap.
import Biased.
require ReprogOnlyRej.

require import DistrExtras.

type X, Y, Z, K.

op [lossless] dXYZ_acc (k : K) : (X * Y * Z) distr.
op [lossless] dXY_rej (k : K) : (X * Y) distr.
op [lossless uniform] dY : Y distr.
op alpha : real.

op dXr k = dfst (dXY_rej k).
axiom dX_pmax k :
  p_max (dXr k) <= alpha.

op qh, qr : int.
axiom qh_gt0 : 0 < qh.
axiom qr_gt0 : 0 < qr.

clone import ReprogOnlyRej as OnlyRej with
  type X <- X,
  type Y <- Y,
  type M <- K,
  op dY <- dY,
  op dXY_rej <- dXY_rej,
  op qh <- qh,
  op qr <- qr,
  op alpha <- alpha
proof *.
realize dXY_rej_ll by apply dXY_rej_ll.
realize dY_ll by apply dY_ll.
realize dY_uni by apply dY_uni.
realize qh_gt0 by apply qh_gt0.
realize qr_gt0 by apply qr_gt0.
realize dX_pmax by apply dX_pmax.

import FullRO.

module type Oracle = {
  proc h(x: X) : Y
  proc reprog_acc(k: K) : X * Y * Z
  proc reprog_rej(k: K) : unit
}.

module type Oracle_i = {
  include Oracle
  proc init() : unit
}.

(*
 * ReprogRej: Basic RO games that we plan to reduce to.
 * Adversary can make three possible queries, as discussed on the notes.
 * Only third query (reprog_rej) is different between GameA and GameB.
 *
 * The games are indistinguishable in ROM.
 * I hope same is true in QROM.
 *)
module ORight : Oracle_i = {
  proc init() = {
    RO.init();
  }

  proc h(x) = {
    var y;
    y <@ RO.get(x);
    return y;
  }

  proc reprog_acc(m) = {
    var x, y, z;
    (x, y, z) <$ dXYZ_acc m;
    RO.set(x, y);
    return (x, y, z);
  }

  proc reprog_rej(k:K) = { }
}.

module OLeft : Oracle_i = {
  include var ORight [init, h, reprog_acc]

  proc reprog_rej(m) = {
    var x, y;
    (x, y) <$ dXY_rej m;
    (* reprog *)
    RO.set(x, y);
    (* no return *)
  }
}.

module type Adversary(O: Oracle) = {
  proc distinguish() : bool
}.

module Game (O: Oracle_i) (Adv: Adversary) = {
  proc main() = {
    var b;
    O.init();
    b <@ Adv(O).distinguish();
    return b;
  }
}.

module Count (O: Oracle) : Oracle = {
  var countR, countH : int
  (*
  proc init() = {
    countR <- 0;
    countH <- 0;
    O.init();
  }
  *)
  proc reprog_acc(x) = {
    var y;
    y <@ O.reprog_acc(x);
    return y;
  }
  proc h(x) = {
    var y;
    countH <- countH + 1;
    y <@ O.h(x);
    return y;
  }
  proc reprog_rej(x) = {
    var y;
    countR <- countR + 1;
    y <@ O.reprog_rej(x);
    return y;
  }
}.

section.

module ORight_rec : Oracle_i = {
  include var ORight [reprog_acc]

  var bad : bool
  var rej_lst : X list

  proc init() = {
    bad <- false;
  }

  proc h(x) = {
    var y;
    if(x \in rej_lst)
      bad <- true;
    y <@ RO.get(x);
    return y;
  }

  proc reprog_rej(m: K) = {
    var x, y;
    (x, y) <$ dXY_rej m;
    rej_lst <- x :: rej_lst;
  }
}.

module OLeft_rec : Oracle_i = {
  include var ORight_rec[init, h, reprog_acc]

  proc reprog_rej(m) = {
    var x, y;
    (x, y) <$ dXY_rej m;
    (* reprog *)
    RO.set(x, y);
    rej_lst <- x :: rej_lst;
    (* no return *)
  }
}.

declare module A <: Adversary {-ORight_rec, -RO, -Count}.
declare axiom A_ll : (forall (O <: Oracle{-A}),
  islossless O.h =>
  islossless O.reprog_acc =>
  islossless O.reprog_rej =>
  islossless A(O).distinguish).
declare axiom A_bound : forall (O <: Oracle{-A}), 
  hoare [ A(Count(O)).distinguish : Count.countR = 0 /\ Count.countH = 0 ==> 
                                    Count.countR <= qr /\ Count.countH = qh ].

lemma ReprogRejBound &m :
  `| Pr[Game(ORight_rec, A).main() @ &m : res]
   - Pr[Game(OLeft_rec, A).main() @ &m : res] |
  <= Pr[Game(OLeft_rec, A).main() @ &m : ORight_rec.bad].
proof.
byequiv (_: ={glob A, RO.m, ORight_rec.bad, ORight_rec.rej_lst} ==>
  ={ORight_rec.bad} /\ (!ORight_rec.bad{1} => ={res})) :
  ORight_rec.bad; 2, 3: smt().
proc.
seq 1 1: (#pre /\ !ORight_rec.bad{1} /\ !ORight_rec.bad{2}).
- inline ORight_rec.init; by auto.
call (_: ORight_rec.bad,
     ={ORight_rec.bad, ORight_rec.rej_lst} /\
     (forall x, (!(x \in ORight_rec.rej_lst{1}) => RO.m{1}.[x] = RO.m{2}.[x])),
     ={ORight_rec.bad}); 1: by apply A_ll.
(* H *)
- proc; inline RO.get; auto => />.
  smt(get_setE get_set_sameE).
- move => *; proc.
  inline RO.get; auto => />.
  smt(dY_ll).
- move => *; proc.
  inline RO.get; auto => />.
  smt(dY_ll).
(* acc *)
- proc. inline RO.set; auto => />.
  smt(get_setE get_set_sameE).
- move => *; proc.
  inline RO.set; auto => />.
  smt(dXYZ_acc_ll).
- move => *; proc.
  inline RO.set; auto => />.
  smt(dXYZ_acc_ll).
(* rej *)
- proc; inline RO.set; auto => />.
  smt(get_setE get_set_sameE).
- move => *; proc; auto => />.
  smt(dXY_rej_ll).
- move => *; proc.
  inline RO.set; auto => />.
  smt(dXY_rej_ll).
(* after call *)
- skip => />; smt().
qed.

end section.
