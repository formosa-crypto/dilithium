require import AllCore Distr List StdOrder.
import RealOrder.

require import DistrExtras RealFLub.

type in_t, out_t.

op d : in_t -> out_t distr.

op alpha : real.

axiom d_pmax z : p_max (d z) <= alpha.

(* Hmm...? *)
lemma d_max : forall z x, mu1 (d z) x <= alpha.
proof.
move => z x.
suff: mu1 (d z) x <= p_max (d z) by smt(d_pmax).
by apply pmax_upper_bound.
qed.

op qs : { int | 0 < qs } as qs_gt0.
op qg : { int | 0 < qg } as qg_gt0.

module type SGOracle = { 
  proc sample (z : in_t) : unit
  proc guess (x : out_t) : unit
}.

module type Adversary (O:SGOracle) = { 
  proc run () : unit
}.

module type SGOracle_i = {
  include SGOracle
  proc init () : unit
}.

module SGO = { 
  var out : out_t list
  var win : bool

  proc init () = { 
    out <- []; 
    win <- false;
  }

  proc sample (z : in_t) = { 
    var x;
    x <$ d z; 
    out <- x :: out;    
  }

  proc guess (x : out_t) = { 
    if (x \in out) { win <- true; }
  }
}.

(* Counting Wrapper *)
module Count (O : SGOracle) : SGOracle = { 
  var cs, cg : int

  proc init () = { 
    cs <- 0;
    cg <- 0;
  }

  proc guess (x) = { 
    cg <- cg + 1;
    O.guess(x);
  }

  proc sample (z) = { 
    cs <- cs + 1;
    O.sample(z);
  }
}.

module SG_Game (A : Adversary) = { 
  proc main () = { 
    SGO.init();
    Count(SGO).init(); (* Add counting wrapper or not? *)
    A(Count(SGO)).run();
    return SGO.win /\ Count.cs <= qs /\ Count.cg <= qg;
  }
}.

(* Variant where the Adversary needs to output its guesses at the end *)

module type SOracle = {
  proc sample (z : in_t) : unit
}.

module type SAdversary (O : SOracle) = { 
  proc guess () : out_t list
}.

module type SOracle_i = {
  include SOracle
  proc init () : unit
  proc get_samples () : out_t list
}.

module SO = { 
  var out : out_t list

  proc init () = { 
    out <- []; 
  }

  proc sample (z : in_t) = { 
    var x;
    x <$ d z; 
    out <- x :: out;    
  }
}.

module SCount (O : SOracle) : SOracle = { 
  var cs : int

  proc init () = { 
    cs <- 0;
  }

  proc sample (z) = { 
    cs <- cs + 1;
    O.sample(z);
  }
}.

module S_Game (A : SAdversary) = { 
  proc main () = {
    var xs;
    SO.init();
    SCount(SO).init(); (* Add counting wrapper or not? *)
    xs <@ A(SCount(SO)).guess();
    return has (mem SO.out) xs /\ SCount.cs <= qs /\ size xs <= qg ;
  }
}.

section PROOF.

declare module A <: Adversary {-Count,-SGO,-SO,-SCount}.

local module (B : SAdversary) (O : SOracle) = { 
  var log : out_t list
  module O' = {
    proc sample = O.sample
    proc guess (x) = { log <- x :: log; }
  }
  proc guess () = { 
    log <- [];
    A(O').run();
    return log;
  } 
}.

local lemma SG_S &m : Pr [ SG_Game(A).main() @ &m : res ] <= Pr [ S_Game(B).main() @ &m : res ].
proof.
byequiv => //; proc; inline*; wp. 
call(: ={out}(SGO,SO) /\ 
       ={cs}(Count,SCount) /\ 
       (Count.cg{1} = size B.log{2}) /\ 
       (SGO.win{1} => has (mem SO.out{2}) B.log{2})).
- proc; inline*; auto => />; smt(has_sym).
- proc; inline*; auto => />; smt(has_sym).
by auto => /> /#.
qed.

lemma SG_bound &m : Pr [ SG_Game(A).main() @ &m : res ] <= qs%r * qg%r * alpha.
admitted.

end section PROOF.

(** Variant with static query bound for A *)

module SG_GameS (A : Adversary) = { 
  proc main () = { 
    SGO.init();
    A(SGO).run();
    return SGO.win;
  }
}.

section STATIC.

declare module A <: Adversary{-Count,-SGO,-SO,-SCount}.

declare axiom A_bound : forall (O <: SGOracle{-A}), 
  hoare [ A(Count(O)).run : Count.cs = 0 /\ Count.cg = 0 ==> 
                            Count.cs <= qs /\ Count.cg = qg ].

lemma SG_boundS &m : Pr [ SG_GameS(A).main() @ &m : res ] <= qs%r * qg%r * alpha.
proof.
apply: ler_trans (SG_bound A &m).
byequiv => //; proc. 
conseq (: ={glob A} ==> ={SGO.win}) _ 
       (: _ ==> Count.cs <= qs /\ Count.cg <= qg) => //.
- by call (A_bound SGO); inline*; auto.
by inline*; call(: ={glob SGO}); 1,2 : proc; inline*; auto.
qed.

end section STATIC.
