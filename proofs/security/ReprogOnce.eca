require import AllCore Distr DBool PROM List.
import Biased.

require import Dexcepted.
require import Dfilter.
require import Real RealSeries.
require import DistrExtras.

(* Define some necessary abstract stuff *)

type M, W, C, Z, ST, PK, SK.

op [lossless] keygen : (PK * SK) distr.
op [lossless] commit : SK -> (W * ST) distr.
op [lossless uniform] dC : C distr.
op respond : ST -> C -> Z option.

op alpha : real. (* pmax *)
op qs : int. (* max. number of signing queries *)
op qh : int. (* max. number of hash queries *)
op kappa : int. (* max. number of iterations *)

require ReprogRej.

clone import ReprogRej as RRej with
  type M = M,
  type X = W * M,
  type Y = C,
  type Z = Z.

import RRej.OnlyRej.FullRO.

module type Oracle = {
  proc h(w: W, m: M) : Y
  proc sign(m: M) : W * C * Z
}.

module Count (O: Oracle) : Oracle = {
  var countS : int
  var countH : int

  proc h(w: W, m : M) : Y = {
    var y;
    countH <- countH + 1;
    y <@ O.h((w, m));
    return y;
  }

  proc sign(x) = {
    var y;
    countS <- countS + 1;
    y <@ O.sign(x);
    return y;
  }
}.

module type Oracle_i = {
  include Oracle
  proc init() : unit
}.

module OLeft : Oracle_i = {
  var sk : SK

  proc init() = {
    var pk;
    (pk, sk) <$ keygen;
  }

  proc h = RO.get

  proc sign(m: M) = {
    var w, st, c, oz, i;
    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;

    i <- 0;
    oz <- None;
    while(oz = None /\ i < kappa) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond st c;
      RO.set((w, m), c);
      i <- i + 1;
    }
    return if i < kappa then (w, c, oget oz) else witness;
  }
}.

(* Moving RO.set outside while-loop *)
module ORight : Oracle_i = {
  include var OLeft[init, h]

  proc sign(m: M) = {
    var w, st, c, oz, i;

    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;

    oz <- None;
    i <- 0;
    while(oz = None /\ i < kappa) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond st c;
      i <- i + 1;
    }
    RO.set((w, m), c);
    return if i < kappa then (w, c, oget oz) else witness;
  }
}.

module type Adversary(O: Oracle) = {
  proc distinguish(): bool
}.

module GameL(Adv: Adversary) = {
  proc main() = {
    var b;
    RO.init();
    OLeft.init();
    b <@ Adv(OLeft).distinguish();
    return b;
  }
}.

module GameR(Adv: Adversary) = {
  proc main() = {
    var b;
    RO.init();
    ORight.init();
    b <@ Adv(ORight).distinguish();
    return b;
  }
}.

(* Next we reorganize transcript computation.
 * We want to first sample f=acc/rej,
 * then sample the rest of transcript conditioned on f.
 *)

(* Transcript distribution *)
op dWCoZ sk : (W * C * Z option) distr =
  dlet (commit sk) (fun wst =>
  let (w, st) = wst in
  dlet dC (fun c =>
  let z = respond st c in
  dunit (w, c, z))).

lemma dWCoZ_ll sk :
  is_lossless (dWCoZ sk).
proof.
apply dlet_ll; first by apply commit_ll.
move => x; case x; move => * /=; apply dlet_ll; first apply dC_ll.
move => * /=; apply dunit_ll.
qed.

(* Transcript distribution, conditioned on accept or reject. *)
op dWCoZ_acc sk = dcond (dWCoZ sk) (fun wcz => let (w, c, z) = wcz in z <> None).
op dWCZ_acc sk = dmap (dWCoZ_acc sk) (fun wcoz => let (w, c, oz) = wcoz in (w, c, oget oz)).
op dWCoZ_rej sk = dcond (dWCoZ sk) (fun wcz => let (w, c, z) = wcz in z = None).
op dWC_rej sk = dmap (dWCoZ_rej sk) (fun wcz => let (w, c, _) = wcz in (w, c)).

(* Accept and reject probabilities *)
op p_acc sk = mu (dWCoZ sk) (fun wcz => let (w, c, oz) = wcz in oz <> None).
op p_rej sk = mu (dWCoZ sk) (fun wcz => let (w, c, oz) = wcz in oz = None).

(* Auxiliary lemma *)

lemma dWCoZ_acc_supp sk w c oz :
  (w, c, oz) \in dWCoZ_acc sk =>
  oz <> None.
proof. smt(dcond_supp). qed.

lemma dWCoZ_rej_None sk w c oz :
  (w, c, oz) \in dWCoZ_rej sk =>
  oz = None.
proof. smt(dcond_supp). qed.

lemma dWCoZ_rej_supp sk w c :
  (w, c, None) \in dWCoZ_rej sk <=>
  (w, c) \in dWC_rej sk.
proof.
split; first by smt(supp_dmap).
rewrite supp_dmap; smt(dWCoZ_rej_None).
qed.

lemma p_rej_E sk :
  p_rej sk = 1%r - p_acc sk.
proof.
rewrite /p_rej.
have ->: (fun wcz : (W * C * Z option)=> let (w, c, oz) = wcz in oz = None) =
      predC (fun wcz => let (w, c, oz) = wcz in oz <> None) by apply fun_ext => ? /#.
have <-: weight (dWCoZ sk) = 1%r by apply dWCoZ_ll.
rewrite mu_not; rewrite /p_acc => //.
qed.

(* Now state the alternative way of sampling transcript is correct *)
lemma conditional_sampling_transcript sk :
  dWCoZ sk = dlet (dbiased (p_acc sk)) (fun f =>
    if f then
      dWCoZ_acc sk
    else
      dWCoZ_rej sk).
proof.
rewrite -dmap_dbiased; first by apply dWCoZ_ll.
rewrite {1} (marginal_sampling (dWCoZ sk) (fun wcoz => let (w, c, oz) = wcoz in oz <> None)) /=.
congr; apply fun_ext => b /=; case b => _.
- rewrite /dWCoZ_acc.
  congr; apply fun_ext => ? /#.
- rewrite /dWCoZ_rej.
  congr; apply fun_ext => ? /#.
qed.

(* Helper module to call bypr... *)
module LoopBodies = {
  include var OLeft[init]
  proc body1() = {
    var w, c, oz;
    (w, c, oz) <$ dWCoZ sk;
    return (w, c, oz);
  }

  proc body2() = {
    var w, c, oz, st;
    (w, st) <$ commit sk;
    c <$ dC;
    oz <- respond st c;
    return (w, c, oz);
  }

  proc body3() = {
    var w, c, oz, f;
    f <$ dbiased (p_acc sk);
    if(f)
      (w, c, oz) <$ dWCoZ_acc sk;
    else
      (w, c, oz) <$ dWCoZ_rej sk;
    return (w, c, oz);
  }

  proc body4() = {
    var w, c, z, f;
    f <$ dbiased (p_acc sk);
    z <- witness; (* silences unused variable warning *)
    if(f)
      (w, c, z) <$ dWCZ_acc sk;
    else
      (w, c) <$ dWC_rej sk;
    return (w, c, f, z);
  }
}.

lemma pr_body1 x &m sk :
  OLeft.sk{m} = sk =>
  Pr[LoopBodies.body1() @ &m : res = x] = mu1 (dWCoZ sk) x.
proof.
move => *.
byphoare (_ : (OLeft.sk = sk) ==> (res = x)) => //=.
proc.
rnd (fun r => r = x).
auto => /#.
qed.

lemma dWCoZ_linearize sk :
  (dlet (commit sk)
        (fun (w_st : W * ST) =>
           dmap dC (fun (c0 : C) => (w_st.`1, c0, respond w_st.`2 c0)))) =
  (dmap (dWCoZ sk)
        (fun (w_c_oz : W * C * Z option) => (w_c_oz.`1, w_c_oz.`2, w_c_oz.`3))).
proof.
  rewrite /dWCoZ => /=.
  have ->: (fun (w_c_oz : W * C * Z option) => (w_c_oz.`1, w_c_oz.`2, w_c_oz.`3)) =
           (fun x => x) by smt().
  rewrite dmap_id; congr => /=.
  apply fun_ext => wst; case wst => ?? /=.
  rewrite /dmap /(\o) => /#.
qed.

equiv hop_body2 :
  LoopBodies.body1 ~ LoopBodies.body2 :
  ={OLeft.sk} ==> ={res}.
proof.
proc.
rnd: *0 *0.
auto => /> &2.
split.
- move => * /=; congr; apply dWCoZ_linearize.
- move => _ wcoz H'. rewrite dWCoZ_linearize => //.
qed.

lemma pr_body2 x &m sk :
  OLeft.sk{m} = sk =>
  Pr[LoopBodies.body2() @ &m : res = x] = mu1 (dWCoZ sk) x.
proof.
move => *.
have <- : Pr[LoopBodies.body1() @ &m : res = x] = Pr[LoopBodies.body2() @ &m : res = x].
  byequiv.
  conseq (_ : ={OLeft.sk} ==> ={res}). trivial. trivial.
  apply hop_body2. trivial. trivial.
rewrite (pr_body1 x &m sk) => /#.
qed.

lemma sum_over_bool (f : bool -> real):
  sum (fun b => f b) = f true + f false.
proof.
rewrite (sumE_fin _ [true; false]) /#.
qed.

equiv hop_body3 :
  LoopBodies.body2 ~ LoopBodies.body3 :
  ={OLeft.sk} ==> ={res}.
proof.
bypr res{1} res{2}; 1: auto => /#.
move => &1 &2 x eq_sk.
rewrite (pr_body2 x &1 OLeft.sk{1}) => //.
byphoare (_: (OLeft.sk = OLeft.sk{1}) ==> (res = x)) => //=; 2: subst => //=.
proc.
seq 1: f (p_acc OLeft.sk{1}) (mu1 (dWCoZ_acc OLeft.sk{1}) x) (p_rej OLeft.sk{1}) (mu1 (dWCoZ_rej OLeft.sk{1}) x) #pre => //=.
- by auto.
- rnd; auto => /> /=.
  rewrite dbiasedE => /=.
  rewrite !clamp_id => //.
  rcondt 1 => //=.
  by rnd (pred1 x); skip => /> /#.
- rnd; auto => /> /=.
  rewrite dbiasedE => /=.
  rewrite !clamp_id => //.
  by rewrite p_rej_E => //=.
- rcondf 1 => //=.
  by rnd (pred1 x); skip => /#.
- move => *; subst.
  rewrite conditional_sampling_transcript.
  rewrite dlet1E /=.
  rewrite sum_over_bool => /=.
  rewrite !dbiased1E => /=.
  rewrite !clamp_id => //=.
  smt(p_rej_E).
qed.

equiv hop_body4 :
  LoopBodies.body3 ~ LoopBodies.body4 :
  ={OLeft.sk} ==> (res{1}.`1 = res{2}.`1 /\
                         res{1}.`2 = res{2}.`2 /\
                         (res{1}.`3 <> None <=> res{2}.`3) /\
                         (res{1}.`3 <> None => oget res{1}.`3 = res{2}.`4)).
proof.
proc; auto.
seq 1 1: (#pre /\ ={f}); 1: auto.
seq 0 1: (#pre); 1: auto.
if; 1: by auto.
- rnd (fun wcoz => let (w, c, oz) = wcoz in (w, c, oget oz))
      (fun wcz => let (w, c, z) = wcz in (w, c, Some z)).
  auto => /> *.
  split => *; first smt().
  split => />.
  - move => wcz; case wcz => w c z ?.
    rewrite dmap1E.
    apply mu_eq_support => x; case x => w' c' z' H /=.
    rewrite /(\o) /pred1 => /=.
    by apply dWCoZ_acc_supp in H => /#.
  - move => _ wcoz; case wcoz => ????.
    move => />; smt(dmap_supp dWCoZ_acc_supp).
- rnd (fun wcoz => let (w, c, oz) = wcoz in (w, c))
      (fun wc => let (w, c) = wc in (w, c, None)).
  auto => /> *. (* terrifying *)
  split => [|_]; first by smt().
  split => [[??] _ |_ [???]] /=; 2: smt(dWCoZ_rej_supp dWCoZ_rej_None).
  rewrite dmap1E /(\o) /pred1.
  by apply mu_eq_support; smt(dWCoZ_rej_None).
qed.

equiv hop_body2_4 :
  LoopBodies.body2 ~ LoopBodies.body4 :
  ={OLeft.sk} ==> (res{1}.`1 = res{2}.`1 /\
                         res{1}.`2 = res{2}.`2 /\
                         (res{1}.`3 <> None <=> res{2}.`3) /\
                         (res{1}.`3 <> None => oget res{1}.`3 = res{2}.`4)).
proof.
transitivity LoopBodies.body3
  (={OLeft.sk} ==> ={res})
  (={OLeft.sk} ==> res{1}.`1 = res{2}.`1 /\
  res{1}.`2 = res{2}.`2 /\
  (res{1}.`3 <> None <=> res{2}.`3) /\
  (res{1}.`3 <> None => oget res{1}.`3 = res{2}.`4)); 1, 2: smt().
- by apply hop_body3.
apply hop_body4.
qed.

(* Loop-bodies brute-forcing spaghetti...
 * RIP signal-to-noise ratio *)

module OLeft_body2 : Oracle_i = {
  include var OLeft[init, h]

  proc sign(m: M) = {
    var w, c, oz, i;
    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;

    i <- 0;
    oz <- None;
    while(oz = None /\ i < kappa) {
      (w, c, oz) <@ LoopBodies.body2();
      RO.set((w, m), c);
      i <- i + 1;
    }
    return if i < kappa then (w, c, oget oz) else witness;
  }
}.

equiv OLeft_body2_call :
  OLeft.sign ~ OLeft_body2.sign :
  ={OLeft.sk, m} ==> ={res}.
proof.
by proc; inline LoopBodies.body2; sim.
qed.

module OLeft_body4 : Oracle_i = {
  include var OLeft[init, h]
 
  proc sign(m: M) = {
    var w, c, f, z, i;
    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;
    z <- witness;

    i <- 0;
    f <- false;
    while(!f /\ i < kappa) {
      (w, c, f, z) <@ LoopBodies.body4();
      RO.set((w, m), c);
      i <- i + 1;
    }
    return if i < kappa then (w, c, z) else witness;
  }
}.

equiv OLeft_loop_bodies_hop :
  OLeft_body2.sign ~ OLeft_body4.sign :
  ={OLeft.sk, m} ==> ={res}.
proof.
proc. seq 4 5: (#pre /\ i{1} = 0 /\ i{2} = 0 /\ oz{1} = None /\ !f{2}); first by auto.
while (={m, OLeft.sk, i} /\ (oz{1} = None <=> !f{2})
         /\ (f{2} => (={w, c} /\ oget oz{1} = z{2}))); 2: by auto => /#.
wp; call(_: true ==> true); first by (proc; auto => //=).
call hop_body2_4; auto => /#.
qed.

(* Replaces the transcript generation with the above *)
module OLeft_cond : Oracle_i = {
  include var OLeft[init, h]

  proc sign(m: M) = {
    var w, c, z, f, i;

    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;
    z <- witness;

    i <- 0;
    f <- false;
    while(!f /\ i < kappa) {
      f <$ dbiased (p_acc sk);
      z <- witness;
      if(f)
        (w, c, z) <$ dWCZ_acc sk;
      else
        (w, c) <$ dWC_rej sk;
      RO.set((w, m), c);
      i <- i + 1;
    }
    return if i < kappa then (w, c, z) else witness;
  }
}.

equiv OLeft_cond_hop : OLeft_body4.sign ~ OLeft_cond.sign :
  ={m, OLeft.sk} ==> ={res}.
proof.
by proc; inline LoopBodies.body4; sim.
qed.

(* Clean up and line up interface.
 * Equivalent to G0A up to reordering instructions. *)
module OLeft_torej : Oracle_i = {
  include var OLeft[init, h]

  proc sign(m: M) = {
    var w, c, z, f, i;

    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;
    z <- witness;

    i <- 0;
    f <- false;
    while(!f /\ i < kappa) {
      f <$ dbiased (p_acc sk);
      z <- witness;
      if(f) {
        (w, c, z) <$ dWCZ_acc sk;
        RO.set((w, m), c);
      }
      else {
        (w, c) <$ dWC_rej sk;
        RO.set((w, m), c);
      }
      i <- i + 1;
    }
    return if i < kappa then (w, c, z) else witness;
  }
}.

equiv OLeft_torej_hop :
  OLeft_cond.sign ~ OLeft_torej.sign :
  ={m, OLeft.sk} ==> ={res}.
proof.
proc.
seq 5 5: (#pre /\ ={w, c, z} /\ i{1} = 0 /\ i{2} = 0 /\ !f{1} /\ !f{2}); first by auto.
while (={m, OLeft.sk, w, c, z, i, f}); last by auto => /#.
seq 2 2: (={m, OLeft.sk, w, c, z, i, f}); first by sim.
if; 1: smt(); 1,2: by sim.
qed.

(**

(* Reduction - G0 corresponds to GA *)
module G0R = {
  var sk : SK

  proc init() = {
    var pk;
    (pk, sk) <$ keygen;
  }

  proc sign(m: M) = {
    var w, c, z, f;

    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;
    z <- witness;

    f <- false;
    while(!f) {
      f <$ dbiased (p_acc sk);
      if(f) {
        (w, c, z) <@ GameA.reprog_acc(dWCZ_acc sk, m);
      }
      else {
        GameA.reprog_rej(dWC_rej sk, m);
      }
    }
    return (w, c, z);
  }
}.

(* TODO equiv G0R.sign ~ G0B.sign?
 * Need to argue min-entropy of dW.
 * Everything else seems trivial.
 *)

(* Reduction - G1 corresponds to GB.
 *
 * TODO Code organization is suspect.
 * Maybe instantiate stuff with module types and parametrized modules?
 * Currently there's (unnecessary-looking) duplicate code.
 * For example, maybe G0R and G1R should be the same too?
 *)
module G1R = {
  var sk : SK

  proc init() = {
    var pk;
    (pk, sk) <$ keygen;
  }

  proc sign(m: M) = {
    var w, c, z, f;

    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;
    z <- witness;

    f <- false;
    while(!f) {
      f <$ dbiased (p_acc sk);
      if(f) {
        (w, c, z) <@ GameB.reprog_acc(dWCZ_acc sk, m);
      }
      else {
        GameB.reprog_rej(dWC_rej sk, m);
      }
    }
    return (w, c, z);
  }
}.

**)

section.

declare module Adv <: Adversary {-OLeft}.

declare axiom A_bound : forall (O <: Oracle{-Adv}), 
  hoare [ Adv(Count(O)).distinguish : Count.countS = 0 /\ Count.countH = 0 ==> 
                                              Count.countS <= qs /\ Count.countH = qh ].

lemma main_bound &m :
`| Pr[GameL(Adv).main() @ &m : res] - Pr[GameR(Adv).main() @ &m : res] | < kappa%r * qs%r * qh%r * alpha.
admitted.

end section.
