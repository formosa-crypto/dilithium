require import AllCore Distr DBool PROM List StdOrder StdBigop FelTactic.
require import Real RealSeries RealSeq Xreal.
(* require import DistrExtras. *)

(*---*) import Bigreal.BRA Bigreal RField.
(*---*) import SmtMap RealOrder Biased FSet.

type M, W, C, Z, ST, PK, SK.

op [lossless] commit : SK -> (W * ST) distr.
op [lossless uniform] dC : C distr.
op respond : SK -> ST -> C -> Z option.

(* We take the maximum abort probability [o] as a theory paramter and
we express the boud in terms of it.  In contrast, we will make eps key
dependent. This will allow us to later reason about the expected min
entropy of commitments *)

op p :   { real | 0%r <= p < 1%r } as p_bounded. 

op bound_reject (sk : SK) =
  mu1 (dlet (commit sk) (fun (w_st : W * ST) =>
    dmap dC (fun (c : C) => respond sk w_st.`2 c))) None <= p.
  
 (* max. number of signing queries *)
op qs : {int | 0 <= qs} as qs_ge0.
(* max. number of hash queries *)
op qh : {int | 0 <= qh} as qh_ge0.

clone import PROM.FullRO as RO with
  type in_t <= W * M,
  type out_t <= C,
  op dout <= (fun _ => dC)
proof *.

(* module type(s) merging the singing oracle and the random (i.e., hash) oracle *)
module type Oracle = {
  proc h(w: W, m: M) : C
  proc sign(m: M) : (W * C * Z)
}.

module type Oracle_i = {
  include Oracle
  proc init(sk_i : SK) : unit
}.

(* counting wrapper for the combined oracles to state query bounds *)
module Count (O: Oracle_i) : Oracle = {
  var countS : int
  var countH : int

  proc init = O.init 

  proc h(w: W, m : M) : C = {
    var y;
    countH <- countH + 1;
    y <@ O.h((w, m));
    return y;
  }

  proc sign(x) = {
    var y;
    countS <- countS + 1;
    y <@ O.sign(x);
    return y;
  }
}.

(* bounding wrapper to avoid out-of-bounds reasoning *) 
(* Note: this also stops couniting once the bound has been reached *)
module CountBound (O: Oracle_i) : Oracle = {
  import var Count

  proc init (sk : SK) = {
    O.init(sk);
    countS <- 0;
    countH <- 0;
  }
  
  proc h(w : W, m : M) : C = {
    var y;
    y <- witness;
    if (countH < qh) { 
      y <@ O.h((w, m));
      countH <- countH + 1;
    }
    return y;
  }

  proc sign(x) = {
    var y;
    y <- witness;
    if (countS < qs) { 
      y <@ O.sign(x);
      countS <- countS + 1;
    }
    return y;
  }
}.

(************************)
(***   Main Oracles   ***)
(************************)

(* The "Real" oracle, infinite signing loop using [RO.get] to obtain
the challenge *)
module OSign : Oracle_i = { var sk : SK var kappa : int

  proc init(sk_i: SK) = {
    sk <- sk_i;
  }

  proc h = RO.get

  proc sign(m: M) = {
    var w, st, c, oz, i;

    w <- witness;
    c <- witness;
    i <- 0;
    oz <- None;
    while(oz = None) {
      (w, st) <$ commit sk;
      c <@ RO.get(w,m);
      oz <- respond sk st c;
      i <- i + 1;
    }
    return (w, c, oget oz);
  }
}.

(* signing oracle usign random challenges 
   - RO is reprogrammed at every iteration
   - loop aborts after kappa attempts  *)
(* TODO: this should be OSet_k *)
module OSet : Oracle_i = {
  include var OSign[init, h]

  proc sign(m: M) = {
    var w, st, c, oz, i;

    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;

    i <- 0;
    oz <- None;
    while(oz = None /\ i < kappa) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
      RO.set((w, m), c); 
      i <- i + 1;
    }
    return if oz <> None then (w, c, oget oz) else witness;
  }
}.


module OSet1 : Oracle_i = {
  import var OSign
  include var OSet[init, h]

  proc sign(m: M) = {
    var w, st, c, oz, i;

    w <- witness;
    c <- witness;
    i <- 0;
    oz <- None;
    (* break out of loop after kappa iterations *)
    while(oz = None /\ i < OSign.kappa) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
      i <- i + 1;
    }
    (* only perform [set] if loop was sucessful *)
    if(oz <> None) RO.set((w, m), c);
    return if oz <> None then (w, c, oget oz) else witness;
  }
}.

(* The overall goal is to bound the difference between interacting
with the oracle [OSign] and the oracle [OTrans] below, both having
no loop bound. *)

module OTrans : Oracle_i = { 
  import var OSign
  include var OSet[init, h]

  proc sign(m: M) = {
    var w, st, c, oz;

    w <- witness;
    c <- witness;
    oz <- None;
    while(oz = None) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
    }
    (* We only store the w and c from the last iteration *) 
    RO.set((w, m), c); 
    return (w, c, oget oz);
  }
}.


(* NOTE: A major complication is that we cannot easily bound the
probability of [OSign.sign] reaching a [kappa] iterations: The
(finite) memory of RO could (a priori) contain only challenges that
lead to rejecting computations. Consequently, there is no intermediate
[OSign_k] game with a bounded while loop. 

To bound the difference, we transition from [OSet_k] to [OSign]
through an "alterating" sequence of hybrid steps. 

1. We extend the last call to [OSet_k.sign] to perform the unbounded
   loop of [OSign.sign] if the [oz = None] after [kappa] tries. 
   (loss p^kappa using syntactic up-to bad)

2. Starting from [kappa], we then successively lower the numer of
   iterations performing the [OSet_k.sign] loop. After [kappa]
   hybrids, the last call has become a call to [OSign.set]. 
   (loss for j-th iteration if the i-th query is:

      d_ij := p^j * (i%r / (1.0 - p) + qh%r + j%r) * eps.

3. Performing (1) and (2) qS times gives a bound of

     qs * p^kappa + 
     qs * eps * ((qs + 1.0)/ (2.0 * (1.0 - p)^2) + qh / (1.0 - p)).

4. The next step is to only reprogram the random oracle on the last
   iteration.  We do this in a setting where the loop is bounded to
   [kappa] iterations. This uses a similar strugture of hybrids and a
   total loss of: 

     qs%r * (qh%r * eps) / (1%r - p).

5. Finally, we perform another up-to-bad argument to remove the loop
   bound. This yields a loss of qs * p^kappa.

6. Finally, we take advantage of the fact that the bound converges as
   kappa is increased to infinity. This yields the final bound (see: 

*)

(* Adversary and Game *)

(* We move to a distinguishing game, i.e., the adversary is no longer
required to output a signature. *)

module type Adversary(O: Oracle) = {
  proc distinguish(pk: PK): bool
}.

(* Distinguishing game for sign/hash oracles *)
module Game (Adv: Adversary) (O: Oracle_i) = {
  proc main(pk_i:PK,sk_i:SK) = {
    var b;
    RO.init();
    O.init(sk_i);
    b <@ Adv(O).distinguish(pk_i);
    return b;
  }
}.

(* Parametric varant, setting OSign.kappa. Oracle implementations
   with loop bounds (have to) use OSign.kappa as the bound *)
module Game_k (Adv: Adversary) (O: Oracle_i) = {
  proc main(pk_i:PK,sk_i:SK, kappa_i: int) = {
    var b;
    OSign.kappa <- kappa_i;
    b <@ Game(Adv, O).main(pk_i,sk_i);
    return b;
  }
}.

lemma Ep_commit_dc_None sk : 
  Ep (commit sk) (fun (w0st : W * ST) =>
    Ep dC (fun (c0_0 : C) => (respond sk w0st.`2 c0_0 = None)%xr)) =
  (mu1 (dlet (commit sk) (fun (wst : W * ST) =>              
    dmap dC (fun (c : C) => respond sk wst.`2 c))) None)%xr.
proof.
  have -> : Ep (commit sk) (fun (w0st : W * ST) =>
              Ep dC (fun (c0_0 : C) => (respond sk w0st.`2 c0_0 = None)%xr))  = 
            Ep (commit sk) (fun (w0st : W * ST) =>
              (mu dC (fun (c0_0 : C) => respond sk w0st.`2 c0_0 = None))%xr).
  + by apply eq_Ep => w0st _ /=; rewrite Ep_mu.
  rewrite -Ep_mu Ep_dlet; apply eq_Ep => x _ /=.
  by rewrite -Ep_mu Ep_dmap; apply eq_Ep.
qed.

abstract theory ReprogAlways.

module type Oracle_i_i = {
  include Oracle
  proc init(sk_i : SK, i:int) : unit
 }.

module type Oracle_i_ij = {
  include Oracle
  proc init(sk_i : SK, i:int, j:int) : unit
 }.

(* ----------------------------------------------------------------- *)
(* Outer Hybrid: 
- answers at most qS signing and qH oracle queries
- first i signing queries perform a [set] on every iteration (sign_l) 
  and abort after kappa tries 
- remaining signing queries perform a [get] and have an unbounded loop 
- only qS queries are answered *)

(* Note: we use j' as the local counter, to keep is distinct from the
fixed j we use when zooming in later *)

module Oi : Oracle_i_i = {
  var sk : SK
  var i_ : int
  var j_ : int
  var countS : int
  var countH : int

  proc init(sk_i:SK, i_i:int) = { 
    i_ <- i_i;
    sk <- sk_i;
    countS <- 0;
    countH <- 0;
  }

  proc h(w : W, m : M) : C = { 
    var y;
    y <- witness;
    if (countH < qh) {
      y <@ RO.get((w, m));
      countH <- countH + 1;
    }
    return y;
  }

  proc sign_i_l (m:M) = {
    var w, st, c, oz;
    (w, st) <$ commit sk;
    c <$ dC;
    oz <- respond sk st c;
    RO.set((w, m), c);
    return (w, c, oz);
  }

  proc sign_l(m : M) = { 
    var w, c, oz, j';

    w <- witness;
    c <- witness;
    j' <- 0;
    oz <- None;
    while(oz = None /\ j' < OSign.kappa ) {
      (w,c,oz) <@ sign_i_l(m);
      j' <- j' + 1;
    }
    return if oz <> None then Some (w, c, oget oz) else None;
  }    

  proc sign_i_r (m:M) = {
    var w, st, c, oz;
    (w, st) <$ commit sk;
    c <@ RO.get(w,m);
    oz <- respond sk st c;
    return (w, c, oz);
  }

  proc sign_r(m : M) = {
    var w, c, oz, j';
    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;

    j' <- 0;
    oz <- None;
    while(oz = None) {
      (w,c,oz) <@ sign_i_r(m);
      j' <- j' + 1;
    }
    return (w, c, oget oz);
  }

  proc sign(m : M) = {
    var or, r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_) {
         or <@ sign_l(m);
         r <- oget or; 
      } else r <@ sign_r(m);
      countS <- countS + 1;
    }
    return r;
  }

}.

(* Inner Hybrid, same distintion as before, but the switch happens
after j iterations on the i-th query to sign.
NOTE: The loop for the i-th query is unbounded *)
module Oij : Oracle_i_ij = {
  include var Oi [h]

  proc init(sk_i:SK, i_i:int, j_i:int) = { 
    i_ <- i_i;
    j_ <- j_i;
    sk <- sk_i;
    countS <- 0;
    countH <- 0;
  }

  proc sign_i (m:M) : W * C * Z = {
    var w, c, oz, j';
    w <- witness;
    c <- witness;
    j' <- 0;
    oz <- None;
 
    while(oz = None) {
      if (j' < j_) 
        (w, c, oz) <@ Oi.sign_i_l (m);
      else 
        (w, c, oz) <@ Oi.sign_i_r (m); 
      j' <- j' + 1;
    }
    return (w, c, oget oz);
  }
  
  proc sign(m:M) = {
    var or, r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_) {
        or <@ Oi.sign_l(m);
        r <- oget or; 
      } else { if (i_ = countS) r <@ sign_i(m);
      else r <@ Oi.sign_r(m); }
      countS <- countS + 1;
    }
    return r;
  }

}.

(** Game wrappers *)
(* TOTHINK: Are these ever instantiated with something oter than Oi/Oij? *)
module Hi (Adv: Adversary) (O: Oracle_i_i) = {
  proc main(pk_i:PK,sk_i:SK,kappa_i:int, i_i:int) = {
    var b;
    OSign.kappa <- kappa_i;
    RO.init();
    O.init(sk_i, i_i);
    b <@ Adv(O).distinguish(pk_i);
    return b;
  }
}.

module Hij (Adv: Adversary) (O: Oracle_i_ij) = {
  proc main(pk_i:PK,sk_i:SK,kappa_i:int, i_i:int, j_i:int) = {
    var b;
    OSign.kappa <- kappa_i;
    RO.init();
    O.init(sk_i, i_i, j_i);
    b <@ Adv(O).distinguish(pk_i);
    return b;
  }
}.


section Analysis.

declare module Adv <: Adversary {-Count, -RO, -OSign, -Oi}.

declare axiom A_bound : forall (O <: Oracle_i{-Adv, -Count}), 
  hoare [ Adv(Count(O)).distinguish : Count.countS = 0 /\ Count.countH = 0 ==> 
                                      Count.countS <= qs /\ Count.countH <= qh ].

declare op pk : PK.
declare op sk : SK.
(* declare axiom sk_entropy : has_entropy sk. *)
op eps = p_max (dfst (commit sk)).
(* op p = mu1 (dlet (commit sk) (fun (w_st : W * ST) =>               *)
(*        dmap dC (fun (c : C) => respond sk w_st.`2 c))) None. *)

(* lemma bound_reject :  *)
(*   mu1 (dlet (commit sk) (fun (w_st : W * ST) =>               *)
(*     dmap dC (fun (c : C) => respond sk w_st.`2 c))) None <= p by done. *)

lemma eps_ge0 : 0%r <= eps by apply pmax_ge0.

declare axiom sk_reject  : bound_reject sk.

(* Since A is query bounded, we can insert CountBound wrappers *)
section CountBound.



(* NOTE: This is complicated by the fact that we do not have that O is lossless. *)
declare module O <: Oracle_i{-Adv, -Count}.

(* Bound queries, but keep counting *)
(* We'll put this into Count, so we need fresh module variables *)
local module CountB (O: Oracle_i) : Oracle = {
  var countS : int
  var countH : int

  proc init (sk : SK) = {
    O.init(sk);
    countS <- 0;
    countH <- 0;
  }
  
  proc h(w : W, m : M) : C = {
    var y;
    y <- witness;
    if (countH < qh) { 
      y <@ O.h((w, m));
    }
    countH <- countH + 1;
    return y;
  }

  proc sign(x) = {
    var y;
    y <- witness;
    if (countS < qs) { 
      y <@ O.sign(x);
    }
    countS <- countS + 1;
    return y;
  }
}.

local equiv Count_CountB : 
  Adv(CountB(O)).distinguish ~ Adv(Count(CountB(O))).distinguish : 
  ={glob CountB,glob O,glob Adv,arg} ==> ={glob CountB}. 
proof.
proc (={glob CountB,glob O}); 1,2: smt().
proc. inline*. wp. sp. if => //. call(:true). auto => />. 
proc. inline*. wp. sp. if => //. call(:true). auto => />. 
qed.

local lemma A_bound2 :  
  hoare [ Adv(CountB(O)).distinguish : 
    CountB.countS = 0 /\ CountB.countH = 0 ==> 
    CountB.countS <= qs /\ CountB.countH <= qh ].
proof.
have H := A_bound (CountB(O)).
conseq Count_CountB (_ :  Count.countS = 0 /\ Count.countH = 0 /\ 
               CountB.countS = 0 /\ CountB.countH = 0 ==> 
               CountB.countS <= qs /\ CountB.countH <= qh); 1,2: smt(). 
conseq (: Count.countS = CountB.countS /\  
          Count.countH = CountB.countH) H; 1,2: smt().
proc (Count.countS = CountB.countS /\ Count.countH = CountB.countH); 1,2: smt().
- by proc; inline*; auto; sp; if; 1: call(: true); auto.
- by proc; inline*; auto; sp; if; 1: call(: true); auto.
qed.

local lemma Pr_CountBound_count &m : 
  Pr[Game(Adv, CountBound(O)).main(pk,sk) @ &m : res] = 
  Pr[Game(Adv, CountB(O)).main(pk,sk) @ &m : res].
proof.
byequiv => //; proc; inline*.
call (: ={glob O} /\ 
        (Count.countH{1} < qh) ? Count.countH{1} = CountB.countH{2} : !(CountB.countH{2} < qh) /\
        (Count.countS{1} < qs) ? Count.countS{1} = CountB.countS{2} : !(CountB.countS{2} < qs)).
- by proc; sp; if; auto; 2: call(: true); auto => /> /#. 
- by proc; sp; if; auto; 2: call(: true); auto => /> /#. 
by auto => />; sim.
qed.

(* TOTHINK: this is needed because Count does not initialize its counters *)
local module GameI (Adv: Adversary) (O: Oracle_i) = {
  proc main(pk_i:PK,sk_i:SK) = {
    var b;
    RO.init();
    O.init(sk_i);
    Count.countS <- 0;
    Count.countH <- 0;
    b <@ Adv(O).distinguish(pk_i);
    return b;
  }
}.

local module CountBad1 : Oracle = {
  var bad: bool
  import var Count

  proc init = O.init 

  proc h(w: W, m : M) : C = {
    var y;
    y <- witness;
    if (countH < qh) { 
      y <@ O.h((w, m)); 
    } else {
      bad <- true;
      y <@ O.h((w, m)); 
    }
    countH <- countH + 1;
    return y;
  }

  proc sign(x) = {
    var y;
    y <- witness;
    if (countS < qs) {
      y <@ O.sign(x); 
    } else {
      bad <- true;
      y <@ O.sign(x);
    }
    countS <- countS + 1;
    return y;
  }
}.

local module CountBad2 : Oracle = {
  import var Count

  proc init = O.init 

  proc h(w: W, m : M) : C = {
    var y;
    y <- witness;
    if (countH < qh) { 
      y <@ O.h((w, m));
    } else CountBad1.bad <- true;
    countH <- countH + 1;
    return y;
  }

  proc sign(x) = {
    var y;
    y <- witness;
    if (countS < qs) { 
      y <@ O.sign(x);
    }
    else CountBad1.bad <- true;
    countS <- countS + 1;
    return y;
  }
}.

local module GameB1 = {
  proc main() = {
    var b;
    CountBad1.bad <- false;
    b <@ GameI(Adv, CountBad1).main(pk,sk);
    return b;
  }
}.

local module GameB2 = {
  proc main() = {
    var b;
    CountBad1.bad <- false;
    b <@ GameI(Adv, CountBad2).main(pk,sk);
    return b;
  }
}.

local lemma Pr_Game_GameI &m : 
  Pr[Game(Adv, Count(O)).main(pk,sk) @ &m : res] =  
  Pr[GameI(Adv, Count(O)).main(pk,sk) @ &m : res /\ Count.countS <= qs /\ Count.countH <= qh].
proof. 
  byequiv => //.
  conseq (: _ ==> ={res}) _ (: true ==> Count.countS <= qs /\ Count.countH <= qh) => />; 2: sim.
  by proc; call (A_bound O); auto.
qed.

local lemma Pr_Count_CountBad1 &m : 
  Pr[GameI(Adv, Count(O)).main(pk,sk) @ &m : res /\ Count.countS <= qs /\ Count.countH <= qh] = 
  Pr[GameB1.main() @ &m : res /\ Count.countS <= qs /\ Count.countH <= qh].
proof.
  byequiv => //; proc; inline GameI(Adv, CountBad1).main; wp.
  sim (Count(O).h ~ CountBad1.h : ={glob O, Count.countH})
      (Count(O).sign ~ CountBad1.sign : ={glob O, Count.countS}).
  + by proc; sp 0 1; if{2}; swap{1} 1; sim. 
  + by proc; sp 0 1; if{2}; swap{1} 1; sim. 
  + by auto.
qed.

local lemma Pr_CountB_CountBad2 &m : 
  Pr[Game(Adv, CountB(O)).main(pk,sk) @ &m : res] =  
  Pr[Game(Adv, CountB(O)).main(pk,sk) @ &m : res /\ CountB.countS <= qs /\ CountB.countH <= qh].
proof. 
  byequiv => //.
  conseq (: _ ==> ={res}) _
         (: true ==> CountB.countS <= qs /\ CountB.countH <= qh) => />; 2: by sim.
  by proc; inline*; call A_bound2; auto.
qed.


local lemma CB2_CB &m : 
  Pr[Game(Adv, CountB(O)).main(pk,sk) @ &m : res] = 
  Pr[GameB2.main() @ &m : res /\ Count.countS <= qs /\ Count.countH <= qh].
proof.
rewrite Pr_CountB_CountBad2.
  byequiv => //; proc.
  inline *; wp.
  sim (CountBad2.h ~ CountBound(O).h : ={glob O, Count.countH})
      (CountBad2.sign ~ CountBound(O).sign : ={glob O, Count.countS}); auto.
qed.

local lemma Pr_CB1_CB2 &m : 
  Pr[GameB1.main() @ &m : res /\ Count.countS <= qs /\ Count.countH <= qh ] = 
  Pr[GameB2.main() @ &m : res /\ Count.countS <= qs /\ Count.countH <= qh ].
proof.
suff : `| Pr[GameB1.main() @ &m : res /\ Count.countS <= qs /\ Count.countH <= qh ] -
          Pr[GameB2.main() @ &m : res /\ Count.countS <= qs /\ Count.countH <= qh ] | <= 0%r by smt().
suff : maxr 
       Pr[GameB1.main() @ &m : (res /\ Count.countS <= qs /\ Count.countH <= qh) /\ CountBad1.bad ]
       Pr[GameB2.main() @ &m : (res /\ Count.countS <= qs /\ Count.countH <= qh) /\ CountBad1.bad ] 
       <= 0%r.
- by apply: ler_trans; byupto.
apply/ler_maxrP; split.
- byphoare => //; hoare; proc; inline*; wp.
  call (: CountBad1.bad => !(Count.countS <= qs /\ Count.countH <= qh)).
  + by proc; sp; if; wp; call (:true); auto => /> /#.
  + by proc; sp; if; wp; call (:true); auto => /> /#.
  auto; call (: true); auto => /> /#.
- byphoare => //; hoare; proc; inline*; wp.
  call (: CountBad1.bad => !(Count.countS <= qs /\ Count.countH <= qh)).
  + proc; sp; if; auto; 1: call(: true);  auto => /> /#.
  + proc; sp; if; auto; 1: call(: true);  auto => /> /#.
  auto; call (: true); auto => /> /#.
qed.

lemma Pr_Count_CountBound &m : 
  Pr[Game(Adv, Count(O)).main(pk,sk) @ &m : res] = 
  Pr[Game(Adv, CountBound(O)).main(pk,sk) @ &m : res].
proof.
rewrite Pr_Game_GameI Pr_Count_CountBad1. 
by rewrite Pr_CountBound_count CB2_CB Pr_CB1_CB2.
qed. 

end section CountBound.


(* ----------------------------------------------------------------- *)
declare op kappa_ : int.
declare axiom kappa_gt0 : 0 < kappa_.

lemma kappa_ge0 : 0 <= kappa_ 
by smt(kappa_gt0).

local lemma GSign_Hi &m : 
  Pr[Game(Adv, CountBound(OSign)).main(pk,sk) @ &m : res] = 
  Pr[Hi(Adv, Oi).main(pk,sk,kappa_, 0) @ &m : res].
proof.
  byequiv => //; proc.
  call (: ={RO.m} /\ OSign.sk{1} = Oi.sk{2} /\ (Oi.i_ <= Oi.countS){2} /\
          Count.countS{1} = Oi.countS{2} /\ Count.countH{1} = Oi.countH{2}).
  + by sim />. 
  + proc; sp; if => //; rcondf{2} ^if; 1: auto => /#.  
    wp; conseq (: y{1} = r{2} /\ OSign.sk{1} = Oi.sk{2} /\ ={RO.m}); 1: smt().
    call (: ={arg, RO.m} /\ OSign.sk{1} = Oi.sk{2} ==> ={res, RO.m} /\ OSign.sk{1} = Oi.sk{2}); 2: by auto.
    proc; inline Oi.sign_i_r. sim.
  inline *; auto.
qed.
  
local lemma GSet_Hi &m : 
  Pr[Game_k(Adv, CountBound(OSet)).main(pk,sk,kappa_) @ &m : res] = 
  Pr[Hi(Adv, Oi).main(pk,sk,kappa_, qs) @ &m : res].
proof.
  byequiv => //; proc; inline Game(Adv, CountBound(OSet)).main; wp.
  call (: ={RO.m, OSign.kappa} /\ OSign.sk{1} = Oi.sk{2} /\ Oi.i_{2} = qs /\ 
          Count.countS{1} = Oi.countS{2} /\ Count.countH{1} = Oi.countH{2}).
  + sim />.
  + proc; sp; if => //.
    rcondt{2} ^if; 1: auto => /#.
    wp; call (: ={arg, RO.m, OSign.kappa} /\ OSign.sk{1} = Oi.sk{2} ==> 
                ={RO.m, OSign.kappa} /\ res{1} = oget res{2} /\
                 OSign.sk{1} = Oi.sk{2}); 2: by auto.
    proc; inline Oi.sign_i_l; wp. 
    by conseq (: ={RO.m, oz, w, c}) => //; 1: smt(); sim.
  by inline *; auto.
qed.

(* TOTHINK: This "loses" the "Pr_Count_CountBound" difference (which
should be 0), where do we exploit that Hi stops answering queries? *)
(* TOTHINK: can we refactor this to use the same direction for the
"telescoping sums"? *)
local lemma GSign_GSet_aux &m : 
  Pr[Game(Adv, Count(OSign)).main(pk,sk) @ &m : res] <= 
  Pr[Game_k(Adv, CountBound(OSet)).main(pk,sk,kappa_) @ &m : res] + 
     bigi predT (fun (i : int) => Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i) @ &m : res] - 
                                    Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i+1) @ &m : res]) 0 qs.
proof.
  have /= <- := telescoping_sum (fun i => Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i) @ &m : res]) 0 qs qs_ge0.
  rewrite -GSign_Hi -GSet_Hi.
  have /# := Pr_Count_CountBound OSign &m.
qed.

(* We focus on 

Pr[Hi(Adv, Oi).main(kappa_, i ) @ &m : res ] -
Pr[Hi(Adv, Oi).main(kappa_, i+1) @ &m : res] 

There are in fact two changes that 

for some fixed i *)
section I.

declare op i : int.
declare axiom i_bounded : 0 <= i < qs.

(* Variant of Oi that sets [badj] if i-th iteration fails to produce a
signature *)
local module OiB1 : Oracle_i_i = {
  include var Oi [-sign]
  var badj : bool

  proc sign(m : M) = {
    var or, r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_ - 1) { 
        or <@ sign_l(m);
        r <- oget or; 
      } else { 
        if (countS = i_ - 1) { 
          or <@ sign_l(m);
          if (or = None) { 
            badj <- true;
            r <- oget or; 
          } else {
            r <- oget or;
          }
        } else r <@ sign_r(m);
      }
      countS <- countS + 1;
    }
    return r;
  }

}.

local module HiB1 = {
  proc main(kappa_i : int, i_i : int) = {
    var b;
    OiB1.badj <- false;
    b <@ Hi(Adv, OiB1).main(pk,sk,kappa_i, i + 1);
    return b;
  }
}.

local lemma Hi_HiB1 &m : 
  Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i + 1) @ &m : res] = 
  Pr[HiB1.main(kappa_, i + 1) @ &m : res].
proof.
  byequiv => //; proc. inline Hi(Adv, OiB1).main; wp.
  call (: ={Oi.sk, Oi.countS, Oi.countH, RO.m, OSign.kappa, Oi.i_}).
  + by sim.
  + proc; sp; if => //.
    if{2}; 1: by rcondt{1} ^if; [auto => /# | sim].
    if{2}; 1: by rcondt{1} ^if; [auto => /# | wp; sim />].
    by rcondf{1} ^if; [auto => /# | sim].
  inline *; auto.
qed.

local module OiB2 : Oracle_i_i = {
  include var Oi [-sign]

  proc sign(m : M) = {
    var or, r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_ - 1) { 
        or <@ sign_l(m);
        r <- oget or;
      } else { 
        if (countS = i_ - 1) { 
          or <@ sign_l(m);
          if (or = None) { 
            OiB1.badj <- true;
            (* If sign_l fails on i-th query, use sign_r *)
            r <@ sign_r(m); 
          } else r <- oget or;
        } else r <@ sign_r(m);
      }
      countS <- countS + 1;
    }
    return r;
  }
}.

local module HiB2 = {
  proc main(kappa_i : int, i_i : int) = {
    var b;
    OiB1.badj <- false;
    b <@ Hi(Adv, OiB2).main(pk,sk,kappa_i, i + 1);
    return b;
  }
}.

local lemma HiB1_HiB2 &m : 
  `| Pr[HiB1.main(kappa_, i + 1) @ &m : res] - Pr[HiB2.main(kappa_, i + 1) @ &m : res] | <= 
     maxr Pr[HiB1.main(kappa_, i + 1) @ &m : OiB1.badj]
          Pr[HiB2.main(kappa_, i + 1) @ &m : OiB1.badj].
proof. byupto. qed.

local ehoare sign_i_l_None : 
  Oi.sign_i_l : (Oi.sk = sk) `|` p%xr ==> (res.`3 = None)%xr.
proof.
  proc; inline *; auto => &hr. 
  apply xle_cxr_r => /> *.
  rewrite Ep_commit_dc_None /= to_pos_pos;1: smt(p_bounded).
  exact sk_reject.
qed.

local ehoare sign_l_None : Oi.sign_l : ((Oi.sk = sk) /\ OSign.kappa = kappa_) `|` (p^kappa_)%xr ==> (res = None)%xr.
proof.
  proc.
  while ( ((Oi.sk = sk) /\ j' <= OSign.kappa) `|` (oz=None)%xr * (p^(OSign.kappa - j'))%xr).
  + by move=> &hr /=; apply xle_cxr_r => |>; smt(expr0).
  + wp => /=. 
    call /(fun x => ((Oi.sk = sk) /\ j' + 1 <= OSign.kappa) `|`x * (p ^ (OSign.kappa - (j' + 1)))%xr)  
         sign_i_l_None.
    auto => &hr /=; apply xle_cxr => |> *; split; 1: smt().
    rewrite !to_pos_pos; 1..3: smt(p_bounded expr_ge0).
    case: (p = 0%r) => [-> /= | ?].
    + by rewrite !expr0z; case (OSign.kappa{hr} - j'{hr} = 0).
    by rewrite -{1}(expr1 p) -exprD; smt(p_bounded).
  by auto => &hr /=; apply xle_cxr => |>; smt (kappa_ge0).
qed.

(* We can bound both OiB1.badj and OiB2.badj by p^kappa_ *)
local lemma HiB1_badj &m : Pr[HiB1.main(kappa_, i + 1) @ &m : OiB1.badj] <= p^kappa_.
proof.
  byehoare (: (kappa_i = kappa_ /\ i_i = i + 1) `|` (p^kappa_)%xr ==> OiB1.badj%xr) => //.
  proc; inline *; wp.
  call /(fun x => x) (: ((Oi.sk = sk) /\ OSign.kappa = kappa_ /\ (Oi.countS < Oi.i_ => !OiB1.badj)) `|` 
             if Oi.countS < Oi.i_ then (p^kappa_)%xr else OiB1.badj%xr).
  + by move=> &hr; apply xle_cxr_r => />; case (Oi.countS{hr} < Oi.i_{hr}) => //= /#. 
  + conseq /(fun _ => ((Oi.sk = sk) /\ OSign.kappa = kappa_ /\ (Oi.countS < Oi.i_ => !OiB1.badj)) `|`
              if Oi.countS < Oi.i_ then (p ^ kappa_)%xr else OiB1.badj%xr) 
           (: 0%xr ==> 0%xr) => //. admit.
  + proc; seq 1: #pre; 1: auto.
    if; wp => /=; 2: by auto => &hr /=; apply xle_cxr => />.
    if. 
    + by wp; conseq /(fun x => ((Oi.sk = sk) /\ OSign.kappa = kappa_ /\ (Oi.countS + 1 < Oi.i_ => !OiB1.badj)) `|`
              if Oi.countS + 1 < Oi.i_ then (p ^ kappa_)%xr else OiB1.badj%xr) 
           (: 0%xr ==> 0%xr) => //= => &hr; apply xle_cxr => /> * /#.
    if.
    + seq 1 : (((Oi.sk = sk) /\ OSign.kappa = kappa_ /\ Oi.countS = Oi.i_ - 1 /\ !OiB1.badj) `|` (or = None)%xr).
      + conseq (: (or = None)%xr).
        + by move=> &hr /=; apply xle_cxr => |> *; apply xle_cxr_l => // /#. 
        + move=> &hr /=; apply xle_cxr. 
          by case: ((Oi.sk = sk){hr} /\ OSign.kappa{hr} = kappa_ /\ Oi.countS{hr} = Oi.i_{hr} - 1 /\ !OiB1.badj{hr}).
        by call sign_l_None; auto => &hr /=; apply xle_cxr => |> /#.
      by auto => &hr /=; apply xle_cxr_r => |>; case:(or{hr} = None).
    conseq /(fun x => ((Oi.sk = sk) /\ OSign.kappa = kappa_ /\ (Oi.countS + 1 < Oi.i_ => !OiB1.badj)) `|`
              if Oi.countS + 1 < Oi.i_ then (p ^ kappa_)%xr else OiB1.badj%xr) 
           (: 0%xr ==> 0%xr) => //=.
    by move=> &hr; apply xle_cxr => /> * /#. 
  auto => &hr /=; apply xle_cxr => /> *; smt(i_bounded).
qed.

(* second part, virtually the same proof *)
local lemma HiB2_badj &m : Pr[HiB2.main(kappa_, i + 1) @ &m : OiB1.badj] <= p^kappa_.
proof.
  byehoare (: (kappa_i = kappa_ /\ i_i = i + 1) `|` (p^kappa_)%xr ==> OiB1.badj%xr) => //.
  proc; inline *; wp.
  call /(fun x => x) (: ((Oi.sk = sk) /\ OSign.kappa = kappa_ /\ (Oi.countS < Oi.i_ => !OiB1.badj)) `|` 
             if Oi.countS < Oi.i_ then (p^kappa_)%xr else OiB1.badj%xr).
  + by move=> &hr; apply xle_cxr_r => />; case (Oi.countS{hr} < Oi.i_{hr}) => //= /#. 
  + by conseq /(fun x => ((Oi.sk = sk) /\ OSign.kappa = kappa_ /\ (Oi.countS < Oi.i_ => !OiB1.badj)) `|`
              if Oi.countS < Oi.i_ then (p ^ kappa_)%xr else OiB1.badj%xr) 
           (: 0%xr ==> 0%xr).
  + proc; seq 1: #pre; 1: auto.
    if; wp => /=; 2: by auto => &hr /=; apply xle_cxr => />.
    if. 
    + by conseq /(fun x => ((Oi.sk = sk) /\ OSign.kappa = kappa_ /\ (Oi.countS + 1 < Oi.i_ => !OiB1.badj)) `|`
              if Oi.countS + 1 < Oi.i_ then (p ^ kappa_)%xr else OiB1.badj%xr) 
           (: 0%xr ==> 0%xr) => //= &hr; apply xle_cxr => /> * /#.
    if.
    + seq 1 : (((Oi.sk = sk) /\ OSign.kappa = kappa_ /\ Oi.countS = Oi.i_ - 1 /\ !OiB1.badj) `|` (or = None)%xr).
      + conseq (: (or = None)%xr).
        + by move=> &hr /=; apply xle_cxr => |> *; apply xle_cxr_l => // /#. 
        + move=> &hr /=; apply xle_cxr. 
          by case: ((Oi.sk = sk){hr} /\ OSign.kappa{hr} = kappa_ /\ Oi.countS{hr} = Oi.i_{hr} - 1 /\ !OiB1.badj{hr}).
        by call sign_l_None; auto => &hr /=; apply xle_cxr => |> /#.
      if; 2: by auto => &hr /=; apply xle_cxr => |>.
      call /(fun _ => ((Oi.sk = sk) /\ OSign.kappa = kappa_ /\ (Oi.countS + 1 < Oi.i_ => !OiB1.badj)) `|`
                       if Oi.countS + 1 < Oi.i_ then (p ^ kappa_)%xr else OiB1.badj%xr)
           (: 0%xr ==> 0%xr) => //.
      by auto => &hr /=; apply xle_cxr => |>.
    by conseq /(fun x => ((Oi.sk = sk) /\ OSign.kappa = kappa_ /\ (Oi.countS + 1 < Oi.i_ => !OiB1.badj)) `|`
              if Oi.countS + 1 < Oi.i_ then (p ^ kappa_)%xr else OiB1.badj%xr) 
           (: 0%xr ==> 0%xr) => //= &hr; apply xle_cxr => /> * /#.
  auto => &hr /=; apply xle_cxr => /> *; smt(i_bounded).
qed.

local lemma Hi_Hij &m : 
  Pr[HiB2.main(kappa_, i + 1) @ &m : res] = 
  Pr[Hij(Adv,Oij).main(pk,sk,kappa_, i, kappa_) @ &m : res].
proof.
  byequiv => //; proc; inline Hi(Adv, OiB2).main; wp.
  call (: ={Oi.sk, Oi.countS, Oi.countH, RO.m, OSign.kappa} /\ Oi.i_{1} = Oi.i_{2} + 1 /\ Oi.j_{2} = OSign.kappa{2} /\ 0 <= OSign.kappa{2}).
  + by sim />.
  + proc; sp; if => //; wp; if{2}.
    + rcondt{1} ^if; 1: by auto => /#.
      by sim />.
    if{2}; last first.
    + rcondf{1} ^if; 1: auto=> /#.
      by rcondf{1} ^if; [auto=> /# | sim />].
    rcondf{1} ^if; 1: by auto => /#.
    rcondt{1} ^if; 1: by auto => /#.  
    inline OiB2.sign_l Oij.sign_i Oi.sign_i_l; wp; conseq />.
    splitwhile{2} ^while : (j' < OSign.kappa).
    seq 7 6 : (={Oi.sk, Oi.countS, Oi.countH, RO.m, OSign.kappa} /\ Oi.i_{1} = Oi.i_{2} + 1 /\ Oi.j_{2} = OSign.kappa{2} /\
              (oz = None => j' = OSign.kappa){2} /\ m{1} = m0{2} /\
              or{1} = if oz{2} <> None then Some (w{2}, c{2}, oget oz{2}) else None).
    + wp.
      while (={m0, w, c, oz, RO.m, Oi.sk, j', OSign.kappa} /\ Oi.j_{2} = OSign.kappa{2} /\ (j' <= OSign.kappa){2}); 2: by auto => /> /#.
      inline RO.set; rcondt{2} ^if; auto; smt().
    if{1}; 2: by rcondf{2} ^while; auto => // /#.
    inline OiB2.sign_r; wp.
    while (={Oi.sk, RO.m, OSign.kappa} /\ m2{1} = m0{2} /\ oz1{1} = oz{2} /\ 
             (oz{2} <> None => w1{1} = w{2} /\ c1{1} = c{2}) /\
             Oi.j_{2} = OSign.kappa{2} /\ (OSign.kappa <= j'){2}); last by auto => /> /#.
    rcondf{2} ^if; 1: auto => /#.
    inline Oi.sign_i_r; wp; conseq (: ={RO.m, st0} /\ c2{1} = c1{2} /\ w2{1} = w1{2}); [smt() | sim].
  by inline *; auto => />; rewrite kappa_ge0.
qed.

local lemma Hi1_Hij &m : 
   Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i) @ &m : res] = 
   Pr[Hij(Adv,Oij).main(pk,sk,kappa_, i,0) @ &m : res].
proof.
  byequiv => //; proc.
  call (: ={Oi.i_, Oi.sk, Oi.countS, Oi.countH, RO.m, OSign.kappa} /\ Oi.j_{2} = 0 /\ 0 < OSign.kappa{2}).
  + by sim />.
  + proc; sp; if => //; wp; if => //; 1: by sim/>.
    if{2}; 2: by sim/>.
    inline Oi.sign_r Oij.sign_i; wp.
    while (={m0, w, c, j', oz, RO.m, Oi.sk, OSign.kappa} /\ (Oi.j_ <= j'){2}); last auto => />. 
    rcondf{2} ^if; auto; 1: smt().
    conseq (: ={m0, RO.m, w, c, oz}); 1: smt(); sim.
  by inline *; auto => />; rewrite kappa_gt0.
qed.

local lemma HiHi1 &m : 
  Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i) @ &m : res] - 
  Pr[Hi(Adv, Oi).main(pk,sk,kappa_,i+1) @ &m : res] <=
  p^kappa_ + 
  bigi predT (fun (j : int) => 
    Pr[Hij(Adv, Oij).main(pk,sk,kappa_,i,j) @ &m : res] - 
    Pr[Hij(Adv, Oij).main(pk,sk,kappa_, i, j+1) @ &m : res]) 0 kappa_.
proof.
  have := HiB1_HiB2 &m; have := HiB1_badj &m; have := HiB2_badj &m.
  have /= <- := (telescoping_sum (fun j => Pr[Hij(Adv, Oij).main(pk,sk,kappa_,i, j) @ &m : res]) 0 kappa_).
  + by apply kappa_ge0.
  rewrite Hi_HiB1 Hi_Hij Hi1_Hij /#.
qed.

(* We focus on 

Pr[Hij(Adv, Oij).main(i,j) @ &m : res] - 
Pr[Hij(Adv, Oij).main(i, j+1) @ &m : res] 

for some fixed j 

Both games behave the same unless the w sampled for the j-th iteration
has been used in a query to the RO (e.g., if the adversary
successfully guessed w) *)

section J.

declare op j : int.
declare axiom j_bounded : 0 <= j < kappa_.

local module OijB1 : Oracle_i_ij = {
  include Oij [init, h]
  import var Oi

  var badRO : bool

  proc sign_i (m:M): (W * C * Z) = {
    var w, c, oz, st, j';
    w <- witness;
    c <- witness;
    j' <- 0;
    oz <- None;
 
    while(oz = None) {
      if (j' < j_) (w, c, oz) <@ Oi.sign_i_l (m);
      else { 
        if (j' = j_) {
          (w, st) <$ commit Oi.sk;
          if ((w,m) \in RO.m) {
            badRO <- true;
            c <@ RO.get(w, m);
            oz <- respond sk st c;
          } else {
            c <$ dC;
            oz <- respond sk st c;
            RO.set((w,m), c);
          }
        } else (w, c, oz) <@ Oi.sign_i_r (m); 
      }
      j' <- j' + 1;
    }
    return if oz <> None then (w, c, oget oz) else witness;
  }
  
  proc sign(m:M) = {
    var or, r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_) { 
         or <@ Oi.sign_l(m); 
         r <- oget or;
      } else {
        if (i_ = countS) r <@ sign_i(m);
        else r <@ Oi.sign_r(m); 
      }
      countS <- countS + 1;
    }
    return r;
  }

}.

local module OijB2 : Oracle_i_ij = {
  include Oij [init, h]
  import var Oi

  proc sign_i (m:M): (W * C * Z) = {
    var w, c, oz, st, j';
    w <- witness;
    c <- witness;
    j' <- 0;
    oz <- None;
 
    while(oz = None) {
      if (j' < j_) (w, c, oz) <@ Oi.sign_i_l (m);
      else { 
        if (j' = j_) {
          (w, st) <$ commit Oi.sk;
          if ((w,m) \in RO.m) {
            OijB1.badRO <- true;
            c <$ dC;
            oz <- respond sk st c;
            RO.set((w,m), c);
          } else {
            c <$ dC;
            oz <- respond sk st c;
            RO.set((w,m), c);
          }
        } else (w, c, oz) <@ Oi.sign_i_r (m); 
      }
      j' <- j' + 1;
    }
    return if oz <> None then (w, c, oget oz) else witness;
  }
  
  proc sign(m:M) = {
    var or, r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_) { 
        or <@ Oi.sign_l(m);
        r <- oget or;
      } else { 
        if (i_ = countS) r <@ sign_i(m);
        else r <@ Oi.sign_r(m); 
      }
      countS <- countS + 1;
    }
    return r;
  }

}.

local module HijB (Adv: Adversary) (O: Oracle_i_ij) = {
  proc main(kappa_i:int, i_i:int, j_i:int) = {
    var b;
    OijB1.badRO <- false;
    OSign.kappa <- kappa_i;
    RO.init();
    O.init(sk, i_i, j_i);
    b <@ Adv(O).distinguish(pk);
    return b;
  }
}.

local lemma Pr_Hij_OijB1 &m : 
  Pr[Hij(Adv, Oij).main(pk,sk,kappa_,i,j) @ &m : res] = Pr[HijB(Adv, OijB1).main(kappa_,i,j) @ &m : res].
proof.
  byequiv => //; proc.
  call (: ={RO.m, Oi.countS, Oi.countH, Oi.sk, OSign.kappa, Oi.i_, Oi.j_}); last by inline *; auto.
  + by sim.
  proc; sp; if => //; wp.
  if => //; 1: by sim.
  if => //; 2: by sim.
  wp; call (: ={RO.m, Oi.countS, Oi.countH, Oi.sk, OSign.kappa, Oi.i_, Oi.j_}); 2: by auto.
  while (={RO.m, Oi.countS, Oi.sk, OSign.kappa, Oi.j_, w, c, oz, j', m}); 2: by auto => /#.
  wp; if => //; 1: by sim.
  inline Oi.sign_i_r; if{2}; 2: by sim.
  seq 2 1 : (#{/ ~{w{2}}}pre /\ m0{1} = m{1} /\ w0{1} = w{2} /\ ={st}); 1: by auto.
  inline *; if{2}.
  + by rcondf{2}^if; 2: rcondf{1}^if; auto.
  rcondt{1}^if; auto => />; smt(get_setE).
qed.

local lemma Pr_Hij_OijB2 &m : 
  Pr[Hij(Adv, Oij).main(pk,sk,kappa_,i,j+1) @ &m : res] = Pr[HijB(Adv, OijB2).main(kappa_,i,j) @ &m : res].
proof.
  byequiv => //; proc.
  call (: ={RO.m, Oi.countS, Oi.countH, Oi.sk, OSign.kappa, Oi.i_} /\ Oi.j_{1} = Oi.j_{2} + 1); last by inline *; auto.
  + by sim />.
  proc; sp; if => //; wp; conseq />.
  if => //; 1: by sim.
  if => //; 2: by sim.
  call (: ={RO.m, Oi.countS, Oi.countH, Oi.sk, OSign.kappa, Oi.i_} /\ Oi.j_{1} = Oi.j_{2} + 1); 2: by auto.
  while (={RO.m, Oi.countS, Oi.sk, OSign.kappa, w, c, oz, j', m} /\ Oi.j_{1} = Oi.j_{2} + 1); 2: by auto => /#.
  wp; conseq (: ={RO.m, w, c, oz}) => //.
  if{2}; 1: by rcondt{1} ^if; [auto => /# | sim].
  if{2}; 2: by rcondf{1} ^if; [auto => /# | sim].
  rcondt{1} ^if; 1: auto => /#.
  inline Oi.sign_i_l.
  seq 2 1 : (#{/ ~{w{2}}}pre /\ m0{1} = m{1} /\ w0{1} = w{2} /\ ={st}); 1: by auto.
  if{2}; sim.
qed.

local lemma Pr_OijB1_OijB2 &m : 
  Pr[HijB(Adv, OijB1).main(kappa_,i,j) @ &m : res] <=
    Pr[HijB(Adv, OijB2).main(kappa_,i,j) @ &m : res] + Pr[HijB(Adv, OijB1).main(kappa_,i,j) @ &m : OijB1.badRO].
proof. byupto. qed.

(* -------------------------------------------------------------------- *)
(* We focus on  Pr[HijB(Adv, OijB1).main(kappa_,i,j) @ &m : OijB1.badRO] *)
import var Oi.

(* With every call to [RO.get] the expected size of the domain increases by one *)
local ehoare ROget : RO.get : (card (fdom RO.m))%xr + 1%xr ==> (card (fdom RO.m))%xr.
proof.
  proc; auto => &hr.
  apply (xle_trans (Ep dC (fun (r:C) => ((card (fdom RO.m{hr}))%rp + 1%rp)%xr))).
  + apply le_Ep => /= c hc.
    case: (x{hr} \notin RO.m{hr}) => hin /=; 2: smt().
    by rewrite fdom_set fcardU1 mem_fdom hin /= /#. 
  by rewrite EpC dC_ll.
qed.

local ehoare e_sign_i_l (c:real) : Oi.sign_i_l : 
  (Oi.sk = ReprogAlways.sk) `|` p%xr * ((card (fdom RO.m))%xr + 1%xr + c%xr) ==> 
  (res.`3 = None)%xr * ((card (fdom RO.m))%xr + c%xr). 
proof.
  proc; inline*; auto => &hr. 
  apply xle_cxr_r => |>. (* /p_def /= ?. *)
  apply (xle_trans 
             (((card (fdom RO.m{hr}))%rp + 1%rp + c%rp) ** 
               Ep (commit ReprogAlways.sk) (fun (w0st : W * ST) =>
                  Ep dC (fun (c0_0 : C) => (respond ReprogAlways.sk w0st.`2 c0_0 = None)%xr)))).
  + rewrite -EpsZ; apply le_Ep => x0 _ /=.
    rewrite -EpsZ; apply le_Ep => C _ /=.
    have ? /#: (card (fdom RO.m{hr}.[x0.`1, m{hr} <- C]))%r%pos <= (card (fdom RO.m{hr}))%r%pos + 1%r.
    by rewrite fdom_set fcardU1 mem_fdom /#. 
  rewrite Ep_commit_dc_None /= mulrC; apply ler_pmul => //. smt(). 
  rewrite to_pos_pos; 1:smt(p_bounded); exact sk_reject.
qed.

local ehoare e_sign_i_l_l  (c:real) : Oi.sign_i_l : 
  (Oi.sk = ReprogAlways.sk) `|` (card (fdom RO.m))%xr + 1%xr + p%xr * c%xr ==> 
  (card (fdom RO.m))%xr + (res.`3 = None)%xr * c%xr. 
proof.
  proc; inline *; auto => &hr. 
  apply xle_cxr_r => |>.
  apply (xle_trans
    ( Ep (commit ReprogAlways.sk) (fun (wst : W * ST) =>
        ((card (fdom RO.m{hr}))%xr + 1%xr) + 
        c%rp ** Ep dC (fun (c0 : C) =>
          (respond ReprogAlways.sk wst.`2 c0 = None)%xr)))).
  + apply le_Ep => wst _ /=.
    have := EpC dC ((card (fdom RO.m{hr}))%xr + 1%xr).
    rewrite dC_ll /= => <-; rewrite -EpsZ -EpD; apply le_Ep => C _ /=.
    by rewrite fdom_set fcardU1 mem_fdom /#. 
  rewrite EpD EpC commit_ll /= EpsZ /= Ep_commit_dc_None /=. 
  apply ler_add => //; rewrite mulrC.
  apply ler_wpmul2r; 1: smt(). 
  rewrite to_pos_pos //; 1: smt(p_bounded); exact sk_reject.
qed.

(* With every call to [sign_l] the expected size of the domain increases by 1 / (1 - p)  *)
local ehoare e_sign_l : Oi.sign_l :  
  (sk = ReprogAlways.sk /\ OSign.kappa = kappa_) `|` (card (fdom RO.m))%xr + (1.0 / (1.0-p))%xr ==> (card (fdom RO.m))%xr.
proof.
  proc.
  while ( (sk = ReprogAlways.sk /\ OSign.kappa = kappa_)`|` (card (fdom RO.m))%xr + 
           (oz = None)%xr * (bigi predT (fun j => (p^j)) 0 (kappa_ - j'))%xr); last first.
  + auto => /= &hr; apply xle_cxr => |> .
    have /= ? := sum_pow_le p kappa_ kappa_ge0 p_bounded.
    apply ler_add => //.
    by rewrite inv_pos; apply le_pos.
  + by move=> &hr /=; apply xle_cxr_r => /> /#.
  wp.
  exlim (bigi predT (fun (j : int) => p ^ j) 0 (kappa_ - (j' + 1))) => sum.
  conseq /(fun x => (sum = (bigi predT (fun (j : int) => p ^ j) 0 (kappa_ - (j' + 1))) /\ sk = ReprogAlways.sk /\
           OSign.kappa = kappa_) `|` x)
     (: (sk = ReprogAlways.sk) `|` ((card (fdom RO.m))%xr + 1%xr + p%xr * sum%xr) ==>
        (card (fdom RO.m))%xr + (oz=None)%xr * sum%xr).
  + move=> &hr /=; apply xle_cxr => /> *.
    rewrite -addrA; apply ler_add => //.
    rewrite (big_ltn 0 (kappa_ -j'{hr})) 1:/#.
    rewrite expr0.
    rewrite (big_reindex _ _ (fun x=> x - 1) (fun x=> x + 1) (range 0 (kappa_ - (j'{hr} + 1)))) //.
    have ->: (transpose Int.(+) 1) = ((+) 1).
    + by apply: fun_ext=> x; ring.
    have -> : kappa_ - (j'{hr} + 1) = kappa_ - j'{hr} - 1 by ring.
    rewrite -(range_addl 0 (kappa_-j'{hr}) 1) /(\o).
    have ? : 0%r <= p by smt(p_bounded).
    rewrite /predT !to_pos_pos //. 
    + by apply sumr_ge0 => /= *; apply expr_ge0.
    + by apply addr_ge0 => //; apply sumr_ge0 => /= *; apply expr_ge0.
    rewrite mulr_sumr /=; apply ler_add => //.
    apply ler_sum_seq => i /mem_range /= *.
    by rewrite -exprS 1:/#.
  + by move=> &hr; apply xle_cxr_r => />.
  call (e_sign_i_l_l sum); auto.
qed.

local ehoare e_sign_i_r : Oi.sign_i_r : OijB1.badRO%xr ==> OijB1.badRO%xr.
proof. by conseq /(fun x => OijB1.badRO%xr) (: 0%xr ==> 0%xr). qed.

(* Main bounding lemma: bounding the probability of [OijB1.badRO] by
the expected size of [RO.m] at the j-th iteration of the i-th query *)
local lemma Pr_bad &m : 
  Pr[HijB(Adv, OijB1).main(kappa_,i,j) @ &m : OijB1.badRO] <= p^j * (i%r / (1.0 - p) + qh%r + j%r) * eps.
proof.
  have ? := p_bounded.
  have ? : 0.0 <= (1.0 - p) by smt().
  have ? : 0.0 <= p ^ j by smt (expr_ge0).
  have ? := i_bounded; have ? := j_bounded; have ? := qh_ge0; have ? := eps_ge0.
  byehoare (: (arg = (kappa_, i, j)) `|` (p^j)%xr * (i%xr / (1.0 - p)%xr + qh%xr + j%xr) * eps%xr ==>
               OijB1.badRO%xr) => //; 2: by rewrite /= /#.
  proc.
  call /(fun x => x) (: 
    ((countS <= i_ => !OijB1.badRO) /\ j_ = j /\ i_ = i /\ sk = ReprogAlways.sk /\ OSign.kappa = kappa_) `|` 
    if countS <= i_ then 
       (p^j)%xr * ((card (fdom RO.m))%xr + (i_ - countS)%xr / (1.0 - p)%xr + (qh - countH)%xr + j%xr ) * eps%xr 
    else OijB1.badRO%xr).
  + move=> &hr; apply xle_cxr_r => /> h.
    case: (countS{hr} <= i) => [ /h ->|//]; rewrite /= !mulr_ge0 /#.
  (* h *)
  + proc; seq 1: #pre; 1: by auto.
    if => /=; 2: by auto => &hr; apply xle_cxr.
    wp. call /(fun c =>  
      ((countS <= i_ => !OijB1.badRO) /\ j_ = j /\ i_ = i /\ sk = ReprogAlways.sk /\ OSign.kappa = kappa_) `|`
      if countS <= i_ then
       (p ^ j)%xr * (c + (i_ - countS)%xr / (1%r - p)%xr +
                     (qh - (countH + 1))%xr + j%xr) * eps%xr
       else OijB1.badRO%xr) ROget; skip.
    move=> &hr; apply xle_cxr => />.
    case: (countS{hr} <= i) => //= *.
    by have -> : (qh - (countH{hr} + 1))%r%pos = (qh - countH{hr})%r%pos - 1%r; smt().
  (* sign *)
  + proc; seq 1: #pre; 1: by auto.
    if; auto; 2: by move=> &hr;apply xle_cxr => />.
    if.
    (* countS < i_ *) 
    + move=> /=; wp.
      call /(fun x => 
       ((countS + 1 <= i_ => !OijB1.badRO) /\ j_ = j /\ i_ = i /\ sk = ReprogAlways.sk /\ OSign.kappa = kappa_) `|`
         if countS + 1 <= i_ then
           (p ^ j)%xr * (x + (i_ - (countS + 1))%xr / (1%r - p)%xr +
              (qh - countH)%xr + j%xr) * eps%xr
        else OijB1.badRO%xr) e_sign_l.
     auto => &hr; apply xle_cxr => |> *.
     have /> * : (countS{hr} + 1 <= i => !OijB1.badRO{hr}) /\ countS{hr} + 1 <= i /\ countS{hr} <= i by smt().
     by have -> : (i - (countS{hr} + 1))%r%pos = (i - countS{hr})%r%pos - 1%r; smt(). 
   
    if.
    (* CountS = i_ *)
    + call /(fun x =>  (i = countS /\ j_ = j /\ i_ = i /\ sk = ReprogAlways.sk /\ OSign.kappa = kappa_) `|` 
                       x + 
                       (p ^ j)%xr * ( (i_ - countS)%xr / (1%r - p)%xr + (qh - countH)%xr) * eps%xr)
            (: (!OijB1.badRO /\ i = countS /\ j_ = j /\ i_ = i /\ sk = ReprogAlways.sk /\ OSign.kappa = kappa_) `|` 
                  (p ^ j)%xr * ((card (fdom RO.m))%xr + j%xr) * eps%xr 
                ==>
                OijB1.badRO%xr); last first.
      + by auto => &hr; apply xle_cxr => |> * /#.
      + move=> &hr /=; apply xle_cxr => />. 
        have -> /= : !(i + 1 <= i); smt().
      proc. while ( 
         ((j' <= j_ => !OijB1.badRO) /\ j_ = j /\ sk = ReprogAlways.sk /\ OSign.kappa = kappa_) `|` 
              if j' <= j_ then 
                let k = j - j' in
                (oz = None)%xr * (p^k)%xr * ((card (fdom RO.m))%xr + k%xr) * eps%xr
              else OijB1.badRO%xr); last first.
      + auto => &hr; apply xle_cxr => |> *.
        by have /> : 0 <= kappa_ /\ 0 <= j by smt(). 
      + move=> &hr /=; apply xle_cxr_r => />.
        by case: (oz{hr} = None) => /= /#.
      wp; if => /=.
      (* j' < j_ *)
      + conseq /(fun x =>
          ((j' + 1 <= j_ => !OijB1.badRO) /\ j_ = j /\ sk = ReprogAlways.sk /\ OSign.kappa = kappa_) `|`
            if j' + 1 <= j_ then
              x *  (p ^ (j - (j' + 1)))%xr * eps%xr
            else OijB1.badRO%xr) 
          (: (sk = ReprogAlways.sk /\ OSign.kappa = kappa_) `|`
             p%xr * ((card (fdom RO.m))%xr + 1%xr + (j - (j' + 1))%xr) ==>
             ((w,c,oz).`3 = None)%xr * ((card (fdom RO.m))%xr + (j - (j' + 1))%xr)).
        + move=> &hr; apply xle_cxr => |> *.
          have /> * : !OijB1.badRO{hr} /\ j'{hr} + 1 <= kappa_ /\ j'{hr} + 1 <= j /\ j'{hr} <= j by smt().
          have -> : (j - j'{hr})%r%pos = (j - (j'{hr} + 1))%r%pos + 1%r by smt().
          have -> : (j - j'{hr}) = (j - (j'{hr} + 1)) + 1 by ring.
          by rewrite exprS /#.
        + move=> &hr; apply xle_cxr => |> *. 
          case: (j'{hr} + 1 <= j) => // /#.
        exlim (j - (j' + 1))%r => j0.
        have h0 := e_sign_i_l j0.
        conseq (:  ((sk = ReprogAlways.sk) `|` p%xr * ((card (fdom RO.m))%xr + 1%xr + j0%xr))
                   ==> 
                   ((w, c, oz).`3 = None)%xr * ((card (fdom RO.m))%xr + j0%xr)).
        + by move=> &hr /=; apply xle_cxr => |>.
        + move=> &hr; apply xle_cxr_r => h; apply h.
        by call h0.
      if => /=.
      (* j' = j_ *)
      + inline *; conseq (: OijB1.badRO%xr).
        + move=> &hr /=; apply xle_cxr => |> *.
          by have /> : !(j + 1 <= j) by smt().
        + by move=> &hr; apply xle_cxr_r => h; apply h.
        auto => &hr; apply xle_cxr_r => |> *.
        rewrite expr0 /=.
        apply (xle_trans (mu (dfst (commit ReprogAlways.sk)) (fun w => w \in map fst (elems (fdom RO.m{hr}))))%xr).
        + rewrite -Ep_mu Ep_dlet; apply le_Ep => wst _ /=.
          rewrite EpC dC_ll /= Ep_dunit /=; case: ((wst.`1, m{hr}) \in RO.m{hr}) => /= ?;
            last by rewrite EpC dC_ll /= /#.
          have -> // : wst.`1 \in unzip1 (elems (fdom RO.m{hr})).
          by rewrite mem_map_fst; exists m{hr}; rewrite -memE mem_fdom.
        rewrite /= !to_pos_pos;[1:smt(fcard_ge0) | 2: apply eps_ge0].
        rewrite cardE -(size_map fst (elems (fdom RO.m{hr}))).
        apply/mu_mem_le_mu1/pmax_upper_bound.
      (* j' > j_ *)
      conseq (: OijB1.badRO%xr ==> OijB1.badRO%xr).
      + move=> &hr; apply xle_cxr_r => |> *.
        apply xle_cxr_l.
        + move=> m0 oz.
          have /> : !(j'{hr} + 1 <= j)  by smt().
        by have -> : !(j'{hr} <= j) by smt().
      + move=> &hr; apply xle_cxr_r => h; apply h.
      by call e_sign_i_r.
    conseq (: OijB1.badRO%xr ==> OijB1.badRO%xr).
    + move=> &hr /=.
      apply xle_cxr => |> *.
      have /> /= : !(countS{hr} + 1 <= i) /\ !(countS{hr} <= i) by smt().
    + move=> &hr; apply xle_cxr_r => h. 
      apply (h (RO.m{hr})).
    inline Oi.sign_r; wp.
    while (OijB1.badRO%xr); last by auto.
    + by move=> &hr; apply xle_cxr_r.
    by wp; call e_sign_i_r; auto => &hr; apply xle_cxr_r.
  (* initialisation *)
  inline *; auto => &hr /=; apply xle_cxr_r => />.
  by rewrite fdom0 fcards0 /= ifT /#.
qed.

lemma concl_j &m: 
  Pr[Hij(Adv, Oij).main(pk,sk,kappa_,i,j) @ &m : res] - Pr[Hij(Adv, Oij).main(pk,sk,kappa_, i, j+1) @ &m : res] <=  
      p^j * (i%r / (1.0 - p) + qh%r + j%r) * eps.
proof. 
  rewrite Pr_Hij_OijB1 Pr_Hij_OijB2.
  move: (Pr_OijB1_OijB2 &m) (Pr_bad &m) => /#.
qed.

end section J.

(* We avoid a dependency on kappa for the second part or the bound by
overapproximating the sum over the Hij steps. This is possible since
the sum converges as kappa grows to infinity. *)
lemma concl_i &m : 
  Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i) @ &m : res] - 
  Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i+1) @ &m : res] <=
    p^kappa_ + 
    ((i%r / (1%r - p) + qh%r) * eps / (1.0 - p) + eps / (1.0 - p)^2).
proof.
apply (ler_trans _ _ _ (HiHi1 &m)); rewrite ler_add2l.
apply (ler_trans (bigi predT (fun (j : int) =>  
         ((i%r / (1.0 - p) + qh%r) * eps) * p^j + eps * (j%r*p^j)) 0 kappa_)).
+ apply ler_sum_seq => j /mem_range hj _ /=.
  by have /# := concl_j j hj &m.
rewrite -sumrD -!mulr_sumr. 
apply ler_add.
+ rewrite ler_wpmul2l; 1: smt(i_bounded p_bounded qh_ge0 eps_ge0).
  by apply (sum_pow_le p kappa_ kappa_ge0 p_bounded).
rewrite ler_wpmul2l 1:eps_ge0.
apply (sum_ipow_le p kappa_ p_bounded).
qed.

end section I.

(* Summing over the Hi steps and simplifying, we obtain : *)
lemma GSign_GSet &m: 
  Pr[Game(Adv, Count(OSign)).main(pk,sk) @ &m : res] <=
  Pr[Game_k(Adv, CountBound(OSet)).main(pk,sk,kappa_) @ &m : res] + 
  (qs%r * p^kappa_ + (qs%r * eps * ((qs%r + 1.0)/ (2.0 * (1.0 - p)^2) + qh%r / (1.0 - p)))).
proof.
  have ? : (1%r - p) <> 0%r by smt(p_bounded).
  have ? : 1%r + (- 2%r) * p + p ^ 2 <> 0%r by smt(expr2).
  apply/(ler_trans _ _ _ (GSign_GSet_aux &m))/ler_add2l. 
  apply (ler_trans 
     (bigi predT (fun (i : int) => 
        p^kappa_ + 
        (i%r * eps / (1.0 -p)^2 + eps * (qh%r / (1.0 - p) + 1.0 / (1.0 - p)^2))) 
     0 qs)).
  + apply ler_sum_seq => i /mem_range hi _ /=.
    apply (ler_trans _ _ _ (concl_i i hi &m)).
    by apply lerr_eq; field. 
  rewrite -sumrD sumri_const 1:qs_ge0 /=.
  apply ler_add; 1: by rewrite mulrC.
  rewrite -sumrD sumri_const 1:qs_ge0 /=.
  rewrite -!mulr_suml sumidE 1:qs_ge0.
  apply lerr_eq; field => // /#. 
qed.

end section Analysis.

end ReprogAlways.


(* This theory proves the bound for the [OSet] to [OTrans] step (?) *)
abstract theory ReprogOnce.

module type Oracle_i_i = {
  include Oracle
  proc init(sk_i : SK, i:int) : unit
}.

module type Oracle_i_ij = {
  include Oracle
  proc init(sk_i : SK, i:int, j:int) : unit
}.

(* Outer Hybrid: 
- answers at most qS signing and qH oracle queries
- first i signing queries perform a [set] on every iteration (sign_l)
- remaining signing queries perform [set] only on last ieration (sign_r) 
- queries to [h] are logged *)

(* Note: we use j' as the local counter, to keep is distinct from the
fixed j we use when zooming in later *)

module Oi : Oracle_i_i = {
  var sk : SK
  var i_ : int
  var logh : W list
  
  var countS : int
  var countH : int

  var j_ : int       (* only used in Oij *)
  var j_end : bool   (* only used in Oij - set if i-th query reaches j-th iteration *)
  var wo : W option  (* only used in Oij *)
  var w_ : W         (* only used in Oij *)
  
  proc init(sk_i:SK, i_i:int) = { 
    i_ <- i_i;
    sk <- sk_i;
    countS <- 0;
    countH <- 0;
    logh <- [];
  }

  proc h(w : W, m : M) : C = { 
    var y;
    y <- witness;
    if (countH < qh) {
      y <@ RO.get((w, m));
      countH <- countH + 1;
      logh <- w::logh;
    }
    return y;
  }

  proc sign_l(m : M) = {
    var w, st, c, oz, j';
 
    w <- witness;
    c <- witness;
    j' <- 0;
    oz <- None;
    while(oz = None /\ j' < OSign.kappa) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
      RO.set((w, m), c);
      j' <- j' + 1;
    }
    return if oz <> None then (w, c, oget oz) else witness;
  }

  proc sign_r(m : M) = { 
    var w, st, c, oz, j';

    w <- witness;
    c <- witness;
    j' <- 0;
    oz <- None;
    while(oz = None /\ j' < OSign.kappa) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
      RO.m <- (oz <> None) ? RO.m.[(w,m) <- c] : RO.m;
      j' <- j' + 1;
    }
    return if oz <> None then (w, c, oget oz) else witness;
  }    

  proc sign(m : M) = {
    var r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_) r <@ sign_l(m);
      else r <@ sign_r(m);
      countS <- countS + 1;
    }
    return r;
  }

}.

(* Inner hybrid:
- [sign] queries 0..i-1 and i+1..qS as in Qi
- on i-th query to [sign]:
  + first j-1 loop iterations perform unconditional set
  + from iteration j+1, only perfom [set] on last iteration
  + for j-th ieraton, 
    * store [w] if this is *not* the last iteration
    * perform [set] if this is the last iteration
*)

module Oij : Oracle_i_ij = {
  include var Oi [-init, sign]

  proc init(sk_i:SK, i_i:int, j_i:int) = { 
    i_ <- i_i;
    j_ <- j_i;
    j_end <- false;
    sk <- sk_i;
    countS <- 0;
    countH <- 0;
    wo <- None;
    w_ <- witness;
    logh <- [];
  }

  proc sign_i_l (m:M) = {
    var w, st, c, oz;
    (w, st) <$ commit sk;
    c <$ dC;
    oz <- respond sk st c;
    RO.set((w, m), c);
    return (w, c, oz);
  }

  proc sign_i_j (m:M) = {
    var st, c, oz;
    (w_, st) <$ commit sk;
    c <$ dC;
    oz <- respond sk st c;
    (* The !j_end and wo = None seems stupid but it is important 
       to be able to prove preservation of bads (for the two next bad events) *)
    wo <- (!j_end /\ wo = None /\ oz = None) ? Some w_ : wo;  
    j_end <- true;
    RO.m <- (oz <> None) ? RO.m.[(w_,m) <- c] : RO.m;
    return (w_, c, oz);
  }

  proc sign_i_r (m:M) = {
    var w, st, c, oz;
    (w, st) <$ commit sk;
    c <$ dC;
    oz <- respond sk st c;
    RO.m <- (oz <> None) ? RO.m.[(w,m) <- c] : RO.m;
    return (w, c, oz);
  }

  proc sign_i (m:M) : W * C * Z = {
    var w, c, oz, j';
    w <- witness;
    c <- witness;
    j' <- 0;
    oz <- None;
    while(oz = None /\ j' < OSign.kappa) {
      if (j' < j_) (w, c, oz) <@ sign_i_l (m);
      else { if (j_ = j') (w, c, oz) <@ sign_i_j (m); 
      else (w, c, oz) <@ sign_i_r (m); }
      j' <- j' + 1;
    }
    return if oz <> None then (w, c, oget oz) else witness;
  }
  
  proc sign(m:M) = {
    var r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_) r <@ sign_l(m);
      else { if (i_ = countS) r <@ sign_i(m);
      else r <@ sign_r(m); }
      countS <- countS + 1;
    }
    return r;
  }

}.

(* Hybrid game for Oi *)
module Hi (Adv: Adversary) (O: Oracle_i_i) = {
  proc main(pk_i:PK,sk_i:SK,kappa_i:int, i_i:int) = {
    var b;
    OSign.kappa <- kappa_i;
    RO.init();
    O.init(sk_i, i_i);
    b <@ Adv(O).distinguish(pk_i);
    return b;
  }
}.

(* Hybrid game for Oij *)
module Hij (Adv: Adversary) (O: Oracle_i_ij) = {
  proc main(pk_i:PK,sk_i:SK,kappa_i:int, i_i:int, j_i:int) = {
    var b;
    OSign.kappa <- kappa_i;
    RO.init();
    O.init(sk_i, i_i, j_i);
    b <@ Adv(O).distinguish(pk_i);
    return b;
  }
}.

section Analysis.

declare module Adv <: Adversary {-Count, -RO, -OSign, -Oi}.

declare axiom A_bound : forall (O <: Oracle_i{-Adv, -Count}), 
  hoare [ Adv(Count(O)).distinguish : Count.countS = 0 /\ Count.countH = 0 ==> 
                                      Count.countS <= qs /\ Count.countH <= qh ].

declare axiom A_ll : forall (O <: Oracle{-Adv}),
  islossless O.h =>
  islossless O.sign =>
  islossless Adv(O).distinguish.

declare op pk : PK.
declare op sk : SK.
op eps = p_max (dfst (commit sk)).
lemma eps_ge0 : 0%r <= eps by apply ge0_pmax.
declare axiom sk_reject  : bound_reject sk.

(* This sections argument is parametric in kappa *)
declare op kappa_ : int.
declare axiom kappa_gt0 : 0 < kappa_.

lemma kappa_ge0 : 0 <= kappa_ 
by smt(kappa_gt0).

(* inline? *)
local lemma GSet_Hi &m : 
  Pr[Game_k(Adv, CountBound(OSet)).main(pk,sk,kappa_) @ &m : res] = 
  Pr[Hi(Adv, Oi).main(pk,sk,kappa_, qs) @ &m : res].
proof.
  byequiv => //; proc; inline{1} Game(Adv, CountBound(OSet)).main; wp.
  call (: ={RO.m, OSign.kappa} /\ OSign.sk{1} = Oi.sk{2} /\ Oi.i_{2} = qs /\ 
          Count.countS{1} = Oi.countS{2} /\ Count.countH{1} = Oi.countH{2}).
  + by sim />. 
  + proc; sp; if => //; rcondt{2} ^if; auto; sim />.
  inline *; auto.
qed.
  
(* inline? *)
local lemma GSet1_Hi &m : 
  Pr[Game_k(Adv, CountBound(OSet1)).main(pk,sk,kappa_) @ &m : res] = 
  Pr[Hi(Adv, Oi).main(pk,sk,kappa_, 0) @ &m : res].
proof.
  byequiv => //; proc; inline Game(Adv, CountBound(OSet1)).main; wp.
  call (: ={RO.m, OSign.kappa} /\ OSign.sk{1} = Oi.sk{2} /\ (Oi.i_ <= Oi.countS){2} /\
          Count.countS{1} = Oi.countS{2} /\ Count.countH{1} = Oi.countH{2}).
  + sim />.
  + proc; sp; if => //.
    rcondf{2} ^if; 1: by auto => /#.
    wp; conseq (: y{1} = r{2} /\ OSign.sk{1} = Oi.sk{2} /\ ={RO.m}); 1: smt().
    inline *; wp.
    by while (={w, c, oz, OSign.kappa} /\ i{1} = j'{2} /\ m{1} = m0{2} /\ OSign.sk{1} = Oi.sk{2} /\
           RO.m{2} = (if oz <> None then RO.m.[(w, m) <- c] else RO.m){1}); auto.
  by inline *; auto.
qed.

(* Express difference between [OSet] and [OSet1] as a sum of differences for Hi/Oi *)
local lemma GSet_GSet1_aux &m: 
    Pr[Game_k(Adv, CountBound(OSet)).main(pk,sk,kappa_) @ &m : res] - 
    Pr[Game_k(Adv, CountBound(OSet1)).main(pk,sk,kappa_) @ &m : res] 
  = bigi predT (fun (i : int) => 
      Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i+1) @ &m : res] - 
      Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i) @ &m : res]) 0 qs.
proof.
rewrite GSet_Hi GSet1_Hi. 
exact (telescoping_sum_down 
        (fun i => Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i) @ &m : res]) 0 qs qs_ge0).
qed.

(* We focus on  

  Pr[Hi(Adv, Oi).main(kappa_, i+1) @ &m : res] - 
  Pr[Hi(Adv, Oi).main(kappa_, i) @ &m : res] 

for some fixed i *)
section I.

declare op i : int.
declare axiom i_bounded : 0 <= i < qs.

(* inline *)
local lemma Hi_Hij &m : 
   Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i) @ &m : res] = 
   Pr[Hij(Adv,Oij).main(pk,sk,kappa_, i, 0) @ &m : res].
proof.
  byequiv => //; proc.
  call (: ={Oi.i_, Oi.sk, Oi.countS, Oi.countH, RO.m, OSign.kappa} /\ Oi.j_{2} = 0).
  + by sim />.
  + proc; sp; if => //; wp; if => //; 1: by sim/>.
    if{2}; 2: by sim/>.
    inline Oi.sign_r Oij.sign_i; wp.
    while (={m0, w, c, j', oz, RO.m, Oi.sk, OSign.kappa} /\ Oi.j_{2} <= j'{2}); last by auto.
    rcondf{2} ^if; 1: by auto => /#.
    by inline *; if{2}; auto => /> /#.
  by inline *; auto.   
qed.    

(* inline*)
local lemma Hi1_Hij &m : 
   Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i+1) @ &m : res] = 
   Pr[Hij(Adv,Oij).main(pk,sk,kappa_, i, kappa_) @ &m : res].
proof.
  byequiv => //; proc.
  call (: ={Oi.sk, Oi.countS, Oi.countH, RO.m, OSign.kappa} /\ 
          Oi.i_{1} = Oi.i_{2} + 1 /\ Oi.j_{2} = OSign.kappa{2}).
  + by sim />.
  + proc; sp; if => //; wp; if{2}.
    + rcondt{1} ^if; 1: by auto => /#.
      by sim />.
    if{2}; 2: by rcondf{1} ^if; [auto=> /# | sim />].
    rcondt{1} ^if; 1: by auto => /#.  
    inline Oi.sign_l Oij.sign_i Oij.sign_i_l; wp.
    while (={m0, w, c, oz, RO.m, Oi.sk, j', OSign.kappa} /\ 
           Oi.j_{2} = OSign.kappa{2}); 2: by auto.
    by inline RO.set; rcondt{2} ^if; auto.
  by inline *; auto.
qed.

local lemma HiHi1 &m : 
  Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i+1) @ &m : res] - 
  Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i) @ &m : res] =
  bigi predT (fun (j : int) => 
    Pr[Hij(Adv, Oij).main(pk,sk,kappa_, i, j+1) @ &m : res] - 
    Pr[Hij(Adv, Oij).main(pk,sk,kappa_, i, j) @ &m : res]) 0 kappa_.
proof.
rewrite Hi_Hij Hi1_Hij.
apply (telescoping_sum_down 
  (fun j => Pr[Hij(Adv, Oij).main(pk,sk,kappa_, i, j) @ &m : res]) 0 kappa_).
exact (kappa_ge0).
qed.

(* We focus on 

    Pr[Hij(Adv, Oij).main(kappa_, i, j+1) @ &m : res] - 
    Pr[Hij(Adv, Oij).main(kappa_, i, j) @ &m : res] 

for some fixed j between 0 and kappa_ *)
section J.

declare op j : int.
declare axiom j_bounded : 0 <= j < kappa_.

op is_update (m1 m2: (W * M, C)fmap) (w:W) = 
  exists m c, m1 = m2.[(w,m) <- c].

lemma is_update_set m1 m2 w k c: is_update m1 m2 w => is_update m1.[k<-c] m2.[k<-c] w.
proof.
  move=> /> m c'; case: (k = (w, m)) => [-> | ? ]; [exists m c | exists m c']; 
    apply fmap_eqP; smt(get_setE).
qed.

local lemma Oij_sign_ll : islossless Oij.sign.
proof.
  islossless. 
  + while true (OSign.kappa - j'); 2: by auto => /#.
    by move=> z; wp; conseq (:true); 1: smt(); islossless.
  + while true (OSign.kappa - j'); 2: by auto => /#.
    by move=> z; wp; conseq (:true); 1: smt(); islossless.
  while true (OSign.kappa - j'); 2: by auto => /#.
  by move=> z; wp; conseq (:true); 1: smt(); islossless.
qed.

(* H_{i,j+1} and H_{i,j} behave the same unless
a) the j-th iteration on the i-th query is reached an not final [Oi.wo = Some w]
b) the adversary queries h using the w of the above iteration. *)
local lemma bad &m : 
  Pr[Hij(Adv, Oij).main(pk,sk,kappa_, i, j+1) @ &m : res] <= 
    Pr[Hij(Adv, Oij).main(pk,sk,kappa_, i, j) @ &m : res] + 
    Pr[Hij(Adv, Oij).main(pk,sk,kappa_, i, j) @ &m : exists w, w \in Oi.logh /\ Oi.wo = Some w].
proof.
  byequiv (: _ ==> !(exists w, w \in Oi.logh /\ Oi.wo = Some w){2} => ={res}) => //; last first.
  + by move=> &1 &2 h1 /h1 ->.
  proc.
  call (: (exists w, w \in Oi.logh /\ Oi.wo = Some w),
          (Oi.countS <= Oi.i_ => !Oi.j_end /\ Oi.wo = None){2} /\
          (forall w, w \in Oi.logh => exists m, (w, m) \in RO.m){2} /\
          ={Oi.countS, Oi.countH, Oi.i_, Oi.sk, Oi.logh, OSign.kappa} /\ 
          Oi.j_{1} = Oi.j_{2} + 1 /\ 0 <= Oi.j_{2} < OSign.kappa{2} /\
          if Oi.wo{2} = None then ={RO.m} else is_update RO.m{1} RO.m{2} (oget Oi.wo{2})).
  + apply A_ll.
  + by proc; inline *; sp; if => //; auto => |>; smt(is_update_set get_setE).
  + by move=> *; islossless.
  + by move=> _; proc; inline *; sp; if => //; auto => />; smt( dC_ll get_setE).
  + proc; sp; if => //; wp.
    if => //.
    + conseq (: _ ==> ={RO.m, r} /\ 
                      (forall w, w \in Oi.logh => exists m, (w, m) \in RO.m){2}); 1: smt().
      inline *; wp.
      while (={m0, w, c, j', oz, RO.m, Oi.sk, OSign.kappa} /\ 
             (forall w, w \in Oi.logh => exists m, (w, m) \in RO.m){2}).
      + by auto => />; smt(get_setE).
      by auto => /> /#.
    if => //; last first.
    + inline *; wp.
      while(={m0,w,c,j',oz, Oi.sk, OSign.kappa} /\ 
            (forall w, w \in Oi.logh => exists m, (w, m) \in RO.m){2} /\
            if Oi.wo{2} = None then ={RO.m}
            else is_update RO.m{1} RO.m{2} (oget Oi.wo{2})).
      + by auto => |>; smt(is_update_set get_setE).
      by auto => |> /#. 
    inline Oij.sign_i RO.set; wp.
    while( (j'{1} <= Oi.j_{2} => !Oi.j_end{2} /\ Oi.wo{2} = None) /\     
            ={Oi.countS, Oi.i_, Oi.sk, j', m0, c, oz, w, OSign.kappa} /\ 
            Oi.j_{1} = Oi.j_{2} + 1 /\ 0 <= Oi.j_{2} /\
             (forall w, w \in Oi.logh => exists m, (w, m) \in RO.m){2} /\
             if (j' <= Oi.j_ \/ Oi.wo = None){2} 
             then ={RO.m} else is_update RO.m{1} RO.m{2} (oget Oi.wo{2})).
    + wp; if{2}.
      + rcondt{1} ^if; 1: by auto => /#.
        by inline *; auto => |>; smt(get_setE).
      if{2}; last first.
      + rcondf{1} ^if; 1: by auto => /#.
        if{1}; inline *; auto => |> *; smt(get_setE is_update_set).
      rcondt{1} ^if; 1: by auto => /#.
      by inline *; auto => />; smt(is_update_set get_setE).
    by auto => /> /#.
  + by move=> _ _; apply Oij_sign_ll.
  + move=> _. 
    conseq Oij_sign_ll 
      (:(exists (w : W), (w \in Oi.logh) /\ Oi.wo = Some w) ==> 
        (exists (w : W), (w \in Oi.logh) /\ Oi.wo = Some w)) => //; 1: smt(). 
    proc; sp; if => //; 2: by auto => />.
    inline *; wp; if.
    + wp; while (exists (w4 : W), (w4 \in Oi.logh) /\ Oi.wo = Some w4); 
       auto; smt(get_setE).
    if; wp; while (exists (w4 : W), (w4 \in Oi.logh) /\ Oi.wo = Some w4); 
       auto; 2..4: smt(get_setE).
    if; 1: by auto; smt(get_setE).
    if; auto; smt(get_setE).
  inline *; auto; smt (j_bounded).
qed.

(* The remainder of this section is mainly about bounding the bad
event from the lemma above:

Pr[Hij(Adv, Oij).main(kappa_, i, j) @ &m : exists w, w \in Oi.logh /\ Oi.wo = Some w].
*)

(* Split the while loop for the i-th signing query, so that j-th loop
iteration is outside of any loops. *)
local module Oij_split : Oracle_i_ij = {
  import var Oi
  include Oij [-sign, sign_i]

  proc sign_i (m:M) : W * C * Z = {
    var w, c, oz, j';
    w <- witness;
    c <- witness;
    j' <- 0;
    oz <- None;
    while(oz = None /\ j' < j_) {
      (w, c, oz) <@ sign_i_l (m);
      j' <- j' + 1;
    }
    j' <- j_; (* this is a no-op if oz = None *)
    if (oz = None /\ j_ < OSign.kappa) (w, c, oz) <@ sign_i_j (m); 
    j' <- j_ + 1;
    while (oz = None /\ j' < OSign.kappa) {
       (w, c, oz) <@ sign_i_r (m); 
      j' <- j' + 1;
    }
    return if oz <> None then (w, c, oget oz) else witness;
  }

  proc sign(m:M) = {
    var r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_) r <@ sign_l(m);
      else { if (i_ = countS) r <@ sign_i(m);
      else r <@ sign_r(m); }
      countS <- countS + 1;
    }
    return r;
  }

}.

local lemma Oij_Oij_split &m : 
  Pr[Hij(Adv, Oij).main(pk,sk,kappa_, i, j) @ &m : exists w, w \in Oi.logh /\ Oi.wo = Some w] = 
  Pr[Hij(Adv, Oij_split).main(pk,sk,kappa_, i, j) @ &m : exists w, w \in Oi.logh /\ Oi.wo = Some w].
proof.
  byequiv => //; proc.
  call (: ={glob Oi, OSign.kappa} /\ 0 <= Oi.j_{2} < OSign.kappa{2}); last by inline *; auto; smt(j_bounded).
  + by sim />.
  proc; sp; if => //.
  if => //; 1: by sim />.
  if => //; 2: by sim />.
  inline Oij.sign_i Oij_split.sign_i.
  sim />.
  splitwhile{1} ^while : (j' < Oi.j_). 
  seq 6 6 : (={glob Oi, OSign.kappa, m0, w, c, j', oz} /\ 
              (0 <= Oi.j_ < OSign.kappa /\ (oz = None => j' = Oi.j_)){2}).
  + while (={glob Oi, OSign.kappa, m0, w, c, j', oz} /\ (j' <= Oi.j_ /\ 0 <= Oi.j_ < OSign.kappa){2}).
    + rcondt{1} ^if; 1: by auto. 
      by wp; conseq (: ={glob Oi, w, c, oz}); [smt() | sim].
    by auto => /> /#.
  sp; if{2}.
  + rcondt{1} ^while; 1: by auto => /#.
    rcondf{1} ^if; 1: by auto => /#.
    rcondt{1} ^if; 1: by auto => /#.
    while (={glob Oi, OSign.kappa, m0, w, c, j', oz} /\ (Oi.j_ < j'){2}).
    + rcondf{1} ^if; 1: by auto => /#.
      rcondf{1} ^if; 1: by auto => /#.
      by wp; conseq (: ={RO.m, w, c, oz}); [ smt() | sim].
    wp; conseq (: ={RO.m, w, c, oz, Oi.wo, Oi.w_, Oi.j_end} /\ j'{1} = Oi.j_{2}); 1: smt().
    by sim => />.
  rcondf{2} ^while; 1: by auto => />.
  by rcondf{1} ^while; auto => />.
qed.

local module Oij_bad : Oracle_i_ij = {
  import var Oi
  include var Oij [-sign, sign_i, sign_i_j]

  (* No need to attempt signing on j-th iteration of i-th query          *)
  (* bad event implies that this iteration cannot be successful          *)
  (* This means w_ is not used, allowing us to (later) defer sampling it *)
  proc sign_i_j (m:M) : W * C * Z option = {
    var st, c;
    (w_, st) <$ commit sk;
    c <$ dC;
    j_end <- true;
    return (witness, c, None);
  }

 (* unchanged, except for calling new [sign_i_j] *)
 proc sign_i (m:M) : W * C * Z = {
    var w, c, oz, j';
    w <- witness;
    c <- witness;
    j' <- 0;
    oz <- None;
    while(oz = None /\ j' < j_) {
      (w, c, oz) <@ sign_i_l (m);
      j' <- j' + 1;
    }
    j' <- j_; (* this is a no-op if oz = None *)
    if (oz = None /\ j_ < OSign.kappa) (w, c, oz) <@ sign_i_j (m); 
    j' <- j_ + 1;
    while (oz = None /\ j' < OSign.kappa) {
       (w, c, oz) <@ sign_i_r (m); 
      j' <- j' + 1;
    }
    return if oz <> None then (w, c, oget oz) else witness;
  }

  proc sign(m:M) = {
    var r;
    r <- witness;
    if (countS < qs) { 
      if (countS < i_) r <@ sign_l(m);
      else { if (i_ = countS) r <@ sign_i(m);
      else r <@ sign_r(m); }
      countS <- countS + 1;
    }
    return r;
  }

}.

(* only possible w is the one from j-th iteration of i-th query *)
(* and only if the j-th iteration is not sucessful              *)
local lemma Oij_split_Oij_bad &m : 
   Pr[Hij(Adv, Oij_split).main(pk,sk,kappa_, i, j) @ &m : exists w, w \in Oi.logh /\ Oi.wo = Some w] <= 
   Pr[Hij(Adv, Oij_bad).main(pk,sk,kappa_, i, j) @ &m : Oi.j_end /\ Oi.w_ \in Oi.logh].
proof. 
  byequiv => //; symmetry; proc. (* why the symmetry?*)
  call (: Oi.j_end /\ Oi.wo = None,
          (Oi.countS <= Oi.i_ => !Oi.j_end /\ Oi.wo = None){2} /\ 
          ={Oi.logh, RO.m, Oi.sk, Oi.countS, Oi.countH, Oi.i_, Oi.j_, Oi.j_end, Oi.w_, OSign.kappa} /\ 
          0 <= Oi.j_{1} < OSign.kappa{2} /\ 
          (Oi.wo <> None => Oi.j_end /\ Oi.wo = Some Oi.w_){2}).
  + apply A_ll.
  + by proc; sp; if => //; inline *; auto.
  + by move=> *; islossless.
  + by move=> _; proc; sp; if => //; inline *; auto => />; smt( dC_ll get_setE).    
  + proc; sp; if => //; wp; if => //.
    + by conseq (: ={r, RO.m}); 1: smt(); sim.
    if => //; wp; last by conseq (: ={r, RO.m}); 1: smt(); sim.
    inline Oij_bad.sign_i Oij_split.sign_i.
    seq 7 7 : (
      (!Oi.j_end /\ Oi.wo = None){2} /\ 
        0 <= Oi.j_{1} < OSign.kappa{2} /\ 
        Oi.i_{1} = Oi.countS{1} /\
        ={Oi.logh, RO.m, Oi.sk, Oi.countS, Oi.countH, Oi.i_, 
          Oi.j_, Oi.j_end, Oi.w_, OSign.kappa, m0, w, c, j', oz}).
    + by conseq (: ={RO.m, m0, w, c, j', oz}); [ smt() | sim].
    inline Oij_bad.sign_i_j Oij_split.sign_i_j.
    seq 2 2 : ( 
      !(Oi.j_end{2} /\ Oi.wo{2} = None) =>
          (={Oi.logh, RO.m, Oi.sk, Oi.countS, Oi.countH, Oi.i_, 
             Oi.j_, Oi.j_end, Oi.w_, OSign.kappa, m0, c, j', oz} /\  
          (Oi.j_end{2} => oz{1} = None) /\ 
          0 <= Oi.j_{1} < OSign.kappa{1} /\
          (Oi.wo{2} <> None => Oi.j_end{2} /\ Oi.wo{2} = Some Oi.w_{2}) /\
          Oi.i_{1} = Oi.countS{1}) /\
      (oz{1}<> None => ={w})).
    + by if; auto => /> /#.
    (* case on if bad is set *)
    case: (Oi.j_end{2} /\ Oi.wo{2} = None).
    + conseq (: true) => />.
      wp; while{1} true (OSign.kappa{1} -j'{1}).
      + by move=> _ z; wp; conseq (:true); [smt() | islossless].
      while{2} true (OSign.kappa{2} -j'{2}); last by auto => /#.
      by move=> _ z; wp; conseq (:true); [smt() | islossless].
    wp; while (={j', oz, c, m0, RO.m, Oi.sk, OSign.kappa} /\ (oz{1} <> None => ={w})).
    + by inline *; auto => /> /#.
    by skip => /> /#.
  + move=> *; islossless.
    + while true (OSign.kappa - j'); 2: by auto => /#.
      by move=> z; wp; conseq (:true); 1: smt(); islossless.
    + while true (OSign.kappa - j'); 2: by auto => /#.
      by move=> z; wp; conseq (:true); 1: smt(); islossless.
    + while true (Oi.j_ - j'); 2: by auto => /#.
      by move=> z; wp; conseq (:true); 1: smt(); islossless.
    while true (OSign.kappa - j'); 2: by auto => /#.
    by move=> z; wp; conseq (:true); 1: smt(); islossless.
  + move=> _; proc; sp; if => //; wp; if.
    + conseq />; islossless.
      while true (OSign.kappa - j'); 2: by auto => /#.
      by move=> z; wp; conseq (:true); 1: smt(); islossless.
    if; last first.
    + conseq />; islossless.
      while true (OSign.kappa - j'); 2: by auto => /#.
      by move=> z; wp; conseq (:true); 1: smt(); islossless.
    inline *; wp.
    (* TOTHINK: Here we use that Oi.wo is changed only if !Oi.j_end          *)
    (* If Oi.j_end, we should have [Oi.countS > Oi.i_] and not call sign_i_j *)
    conseq (: true ==> true) (: Oi.j_end /\ Oi.wo = None ==> Oi.j_end /\ Oi.wo = None) => //.
    + while true => //.
      wp; seq 7 : (Oi.j_end /\ Oi.wo = None) => //.
      + by conseq />.
      by if; auto => /#.
    islossless.
    + while true (OSign.kappa - j'); 2: by auto => /#.
      by move=> z; wp; conseq (:true); 1: smt(); islossless.
    while true (Oi.j_ - j'); 2: by auto => /#.
    by move=> z; wp; conseq (:true); 1: smt(); islossless.
  inline *; auto => />; smt(j_bounded).
qed.


(* We now rephrase the game as a distinguisher for random
oracles. This will allow us to replace the default implementation of
the oracle with a lazy one. Note, that we'll call the RO at most once,
during the j-th iteration of the i-th sign query.  *)

(* TOTHINK: use [dout = fun sk => dfst (commit sk)] instead? *)
local clone PROM.FullRO as ROsk with
  type in_t <= SK, 
  type out_t <= W * ST,
  op dout <= commit,
  type d_in_t <= int * int * int,
  type d_out_t <= bool
proof *.

local module Oij_LE (H : ROsk.RO) : Oracle_i_ij = {
  import var Oi
  include var Oij [-sign, sign_i, sign_i_j]

  (* i_done is used when we do fel *)
  (* TOTHINK: Isn't this equivalent to [i_ < countS] *)
  var i_done : bool

  proc sign_i (m:M): W * C * Z = {
    var w <- witness;
    var c <- witness;
    var j' <- 0;
    var oz <- None;
    if (!i_done /\ Oi.sk = ReprogOnce.sk) {
    while(oz = None /\ j' < j) {
      (w, c, oz) <@ sign_i_l (m);
      j' <- j' + 1;
    }
    j' <- j_; (* this is a no-op if oz = None *)
    if (oz = None /\ j_ < OSign.kappa) { 
        H.sample(sk);
        c <$ dC;
        j_end <- true;
        w <- witness;
        oz <- None;
    }
    j' <- j_ + 1;
    while (oz = None /\ j' < OSign.kappa) {
       (w, c, oz) <@ sign_i_r (m); 
      j' <- j' + 1;
    }
    i_done <- true;
    }
    return if oz <> None then (w, c, oget oz) else witness;
  }

  proc sign(m:M) = {
    var r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_) r <@ sign_l(m);
      else { if (i_ = countS) r <@ sign_i(m);
      else r <@ sign_r(m); }
      countS <- countS + 1;
    }
    return r;
  }
}.

local module D (H :  ROsk.RO) = {

  proc distinguish1 (kappa_i:int, i_i:int, j_i:int) = {
    var b;
    OSign.kappa <- kappa_i;
    Oij_LE.i_done <- false;
    RO.init();
    H.init();
    Oij_LE(H).init(sk, i_i, j_i);
    b <@ Adv(Oij_LE(H)).distinguish(pk);
  }

  proc distinguish (kappa_i:int, i_i:int, j_i:int) = {
    var st;
    distinguish1 (kappa_i, i_i, j_i);
    (Oi.w_, st) <@ H.get(Oi.sk);
    (* TOTHINK: The b2i part is just true ... *)
    return (Oi.j_end /\ b2i Oij_LE.i_done <= 1) /\ Oi.w_ \in Oi.logh;
  }

}.

local lemma Oij_bad_DRO &m : 
  Pr[Hij(Adv, Oij_bad).main(pk,sk,kappa_, i, j) @ &m : Oi.j_end /\ Oi.w_ \in Oi.logh] = 
  Pr[D(ROsk.RO).distinguish(kappa_, i, j) @ &m : res].
proof.
  byequiv (: ={glob Adv, i_i,j_i,kappa_i} /\ sk_i{1} = sk /\ pk_i{1} = pk /\ i_i{1} = i /\ j_i{1} = j ==> _) => //.
  proc; wp; inline D(ROsk.RO).distinguish1. sp 1 4.
  seq 3 5: (={Oi.j_end, Oi.logh} /\
             (Oi.j_end => exists st, ROsk.RO.m.[Oi.sk] = Some (Oi.w_{1}, st)){2});
    last first.
  + case: (Oi.j_end{2}). 
    + by inline *; rcondf{2} ^if; auto => /> /#.
    by call{2} (:true ==> true); [islossless | auto].
  call (: ={RO.m, Oi.j_end, Oi.j_, Oi.logh, Oi.countH, Oi.countS, Oi.countH, Oi.sk, Oi.i_, OSign.kappa} /\
          Oi.j_{2} = j /\ Oi.sk{2} = sk /\
          (Oi.countS <= Oi.i_ => (!Oij_LE.i_done /\ !Oi.j_end /\ Oi.sk \notin ROsk.RO.m)){2} /\
          (Oi.j_end => exists st, ROsk.RO.m.[Oi.sk] = Some (Oi.w_{1}, st)){2}).
  + by sim />.
  + proc; sp; if => //; wp; if => //; 2: if => //; last first.
    + by conseq (: ={r, RO.m}); [smt() | sim].
    + by conseq (: ={r, RO.m}); [smt() | sim].
    inline Oij_bad.sign_i Oij_LE(ROsk.RO).sign_i.
    rcondt{2} ^if; 1: auto => /> /#.
    wp; while (={RO.m, m0, oz, w, c, j', Oi.sk, OSign.kappa}).
    + by inline *; auto.
    wp; seq 7 7 :
      (={RO.m, m0, oz, w, c, j', Oi.sk, Oi.j_end, Oi.j_, 
         Oi.logh, Oi.countH, Oi.countS, Oi.sk, Oi.i_, OSign.kappa} /\
      Oi.j_{2} = j /\ Oi.sk{2} = sk /\
      (!Oi.j_end /\  Oi.sk \notin ROsk.RO.m /\ Oi.countS = Oi.i_){2}).
    + conseq (: ={RO.m, m0, oz, w, c, j', Oi.sk, Oi.j_end, 
                  Oi.j_, Oi.logh, Oi.countH, Oi.countS, Oi.sk, Oi.i_}); 1: smt().
      wp; while (={RO.m, m0, oz, w, c, j', Oi.sk} /\  Oi.j_{1} = j); last by auto.
      by conseq (: ={RO.m, oz, w, c, j'}) => />; sim.
    if=> //; 2: auto => /> /#.
    by inline *; rcondt{2} ^if; auto => />; smt(get_setE).
  by inline *; auto => /> *; rewrite mem_empty /= /#.
qed.

local lemma DRO_DLRO &m : 
  Pr[D(ROsk.RO).distinguish(kappa_, i, j) @ &m : res] = 
  Pr[D(ROsk.LRO).distinguish(kappa_, i, j) @ &m : res].
proof. byequiv (ROsk.FullEager.RO_LRO_D D commit_ll) => //. qed.


(* Next we bound the probability that the j-th iteration is reached
(and unsuccessfull) on the i-th query. *)
local lemma phr_j_end:
  phoare [D(ROsk.LRO).distinguish1 : 
      kappa_i = kappa_ /\ i_i = i /\ j_i = j ==> Oi.j_end ] <= (p ^ j).
proof. 
  conseq (: Oi.j_end /\ b2i (Oij_LE.i_done) <= 1); 1: smt(). 
  bypr => &m *.
  fel 5 (b2i (Oij_LE.i_done)) (fun _ => p ^ j) 1 Oi.j_end
      [Oij_LE(ROsk.LRO).sign_i : (!Oij_LE.i_done /\ Oi.sk = ReprogOnce.sk)]
      true => //.
  + by have /= -> := big_int1 0.
  + by inline *; auto.
  + proc; rcondt^if; 1:by auto.
    seq 6 : (oz = None) (p^j) 1%r _ 0%r (!Oi.j_end) => //.
    + by conseq /> => //.
    + sp; wp; conseq (: _ : <= (if oz = None then p ^ (j - j') else 0%r)) => //.
      while (j' <= j /\ Oi.sk = sk).
      + move=> hw; exlim j' => j0.
        conseq (: _ : <= (if oz = None then p ^ (j - j0) else 0%r)) => //.
        seq 2 : (oz = None) p (p^(j - (j0 + 1))) _ 0%r (j' = j0 + 1 /\ j' <= j /\ Oi.sk = sk).
        + by wp; conseq (:true) => // /#.
        + wp; inline *; wp 4.
          rndsem 1.
          rnd (fun (wscoz: _ * _ * _ * _) => wscoz.`4 = None).
          auto => |> &hr hv; apply: ler_trans sk_reject. 
          apply mu_dlet_le => w_st _ /=; apply mu_dlet_le => c.
          by rewrite dunitE dunit1E.
        + by conseq hw => />. 
        + by conseq hw => /#.
        move=> /> *; rewrite -exprS /#. 
      by auto => />; smt (expr0 j_bounded).
    by rcondf^if; 1: auto => />; conseq />.
  + move=> c; proc; rcondt^if; wp; 1: by auto.
    by conseq (:true) => />; auto.
  by move=>*; proc; rcondf^if; auto.
qed.

(* using the lemma above, we can bound the probability of D (with a
   lazy RO) returning true *)
local lemma Pr_DLRO &m : Pr[D(ROsk.LRO).distinguish(kappa_, i, j) @ &m : res] <= p^j * (qh%r * eps).
proof.
  byphoare ( : kappa_i = kappa_ /\ i_i = i /\ j_i = j ==> res) => //; proc.
  seq 1 : Oi.j_end (p ^ j) (qh%r * eps) _ 0%r 
          (Oi.sk \notin ROsk.RO.m /\ size Oi.logh <= qh /\ Oi.sk = ReprogOnce.sk) => //;
    last by conseq (:false) => />.  
  + inline D(ROsk.LRO).distinguish1.
    call (: Oi.sk \notin ROsk.RO.m /\ size Oi.logh <= Oi.countH <= qh /\ Oi.sk = ReprogOnce.sk).
    + by proc; sp; if => //; wp; conseq (:true) => // /#. 
    + by conseq />.
    inline *; auto => />; smt(qh_ge0 mem_empty).  
  (* [ : Oi.j_end ] <= p ^ j *)
  + call (phr_j_end); auto => />.
  (* [w_ <@ dfst (commit sk) : w_ \in logh ] *)
  inline *; rcondt ^if; 1: by auto.
  wp; rnd (fun x => fst x \in Oi.logh); auto => |> &hr ? hsize hval; split; 2: smt(get_setE).
  have := mu_mem_le_mu1 (dfst (commit sk)) Oi.logh{hr} eps _; 1: exact: pmax_upper_bound.
  rewrite /dfst dmapE /(\o); smt (eps_ge0 size_ge0).
qed.

lemma concl_j &m: 
  Pr[Hij(Adv, Oij).main(pk,sk,kappa_, i, j+1) @ &m : res] - 
  Pr[Hij(Adv, Oij).main(pk,sk,kappa_, i, j  ) @ &m : res] <=  p^j * (qh%r*eps).
proof.
  have := bad &m; have := Oij_split_Oij_bad &m; have := Pr_DLRO &m.
  rewrite (Oij_Oij_split &m) (Oij_bad_DRO &m) (DRO_DLRO &m) /#.
qed.

end section J.

lemma concl_i &m : 
  Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i+1) @ &m : res] - Pr[Hi(Adv, Oi).main(pk,sk,kappa_, i) @ &m : res] <=
    (qh%r * eps) / (1%r - p).
proof.
  apply (ler_trans (bigi predT (fun (j : int) =>  p^j * (qh%r * eps)) 0 kappa_)).
  + rewrite (HiHi1 &m); apply ler_sum_seq => j /mem_range hj _ /=.
    by apply concl_j.
  rewrite -mulr_suml; have := sum_pow_le p kappa_ _ _; smt(kappa_gt0 p_bounded qh_ge0 eps_ge0).
qed.

end section I.

lemma GSet_GSet1 &m: 
  Pr[Game_k(Adv, CountBound(OSet )).main(pk,sk,kappa_) @ &m : res] <= 
  Pr[Game_k(Adv, CountBound(OSet1)).main(pk,sk,kappa_) @ &m : res] + qs%r * (qh%r * eps) / (1%r - p).
proof.
  rewrite addrC -ler_subl_addr.
  apply (ler_trans (bigi predT (fun (j : int) =>  (qh%r * eps)/(1%r - p)) 0 qs)).
  rewrite GSet_GSet1_aux; apply ler_sum_seq => i /mem_range hi _ /=.
  apply (concl_i i hi).
  rewrite sumri_const 1:qs_ge0 //.
qed.

(* ---------------------------------------------------------------- *)
(* Now we go back to an infinite number of loop iterations          *)
(* This allows to remove the dependency on kappa_                   *)

local module OSet1B1 : Oracle_i = {
  import var OSign
  include var OSet[init, h]
  var bad : bool

  proc sign(m: M) = {
    var w, st, c, oz, i;

    w <- witness;
    c <- witness;
    i <- 0;
    oz <- None;
    while(oz = None /\ i < OSign.kappa) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
      i <- i + 1;
    }
    if (oz = None) { 
       bad <- true;
    }
    if(oz <> None) RO.set((w, m), c);
    return if oz <> None then (w, c, oget oz) else witness;
  }
}.

local module OSet1B2 : Oracle_i = {
  import var OSign
  include var OSet[init, h]

  proc sign(m: M) = {
    var w, st, c, oz, i;

    w <- witness;
    c <- witness;
    i <- 0;
    oz <- None;
    while(oz = None /\ i < OSign.kappa) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
      i <- i + 1;
    }
    if (oz = None) { 
      OSet1B1.bad <- true;
      while(oz = None) {
        (w, st) <$ commit sk;
        c <$ dC;
        oz <- respond sk st c;
      }
    }
    if(oz <> None) RO.set((w, m), c);
    return if oz <> None then (w, c, oget oz) else witness;
  }
}.

local module OTrans_i : Oracle_i = { 
  import var OSign
  include var OSet[init, h]

  proc sign(m: M) = {
    var w, st, c, oz, i;

    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;

    i <- 0;
    oz <- None;
    while(oz = None) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
      i <- i + 1;
    }
    RO.set((w, m), c);
    return (w, c, oget oz);
  }
}.

local module Game_kb(O:Oracle_i) = { 
  proc main (kappa_i:int) = { 
    var b;
    OSet1B1.bad <- false;
    b <@ Game_k(Adv, CountBound(O)).main(pk,sk,kappa_i);
    return b;
  }
}.
  
local lemma Set1_Set1B1 &m : 
  Pr[Game_k(Adv, CountBound(OSet1)).main(pk,sk,kappa_) @ &m : res] =
  Pr[Game_kb(OSet1B1).main(kappa_) @ &m : res].
proof. byequiv => //; proc; inline *; sim; auto. qed.

local lemma Set1B1_Set1B2 &m: 
  Pr[Game_kb(OSet1B1).main(kappa_) @ &m : res] <= 
   Pr[Game_kb(OSet1B2).main(kappa_) @ &m : res] + Pr[Game_kb(OSet1B1).main(kappa_) @ &m : OSet1B1.bad].
proof. byupto. qed.

local lemma Set1B2_Trans_i &m : 
  Pr[Game_kb(OSet1B2).main(kappa_) @ &m : res] =
  Pr[Game(Adv, CountBound(OTrans_i)).main(pk,sk) @ &m : res].
proof.
  byequiv=> //; proc; inline *; wp.
  call (: ={RO.m, OSign.sk, Count.countH, Count.countS} /\ OSign.kappa{1} = kappa_); last by auto.
  + by sim />.
  proc; sp; if => //.
  inline OSet1B2.sign OTrans_i.sign.
  splitwhile{2} ^while  : (i < kappa_).
  seq 6 6 : (={ m, w, c, i, oz, RO.m, OSign.sk, Count.countH, Count.countS} /\ OSign.kappa{1} = kappa_).
  + while (={ m, w, c, i, oz, OSign.sk} /\ OSign.kappa{1} = kappa_); 2: by auto.
    by conseq (: ={w, c, i, oz}) => //; sim.
  inline RO.set; if{1}.
  + by wp; while (={ m, w, c, oz, OSign.sk}); [ sim | auto => />].
  rcondf{2} ^while; 1: by auto.
  by rcondt{1} ^if; auto => />. 
qed.

local lemma Set1_i_Trans &m : 
   Pr[Game(Adv, CountBound(OTrans_i)).main(pk,sk) @ &m : res] = 
   Pr[Game(Adv, CountBound(OTrans)).main(pk,sk) @ &m : res].
proof. byequiv => //; sim. qed.

local lemma Pr_bad &m : Pr[Game_kb(OSet1B1).main(kappa_) @ &m : OSet1B1.bad] <= qs%r * p^kappa_.
proof.
  byehoare (: (kappa_i = kappa_) `|` (qs%r * p ^ kappa_)%xr  ==> _)=> //; proc. 
  inline Game_k(Adv, CountBound(OSet1B1)).main Game(Adv, CountBound(OSet1B1)).main; wp.
  call /(fun x => x) (: (OSign.sk = sk /\ OSign.kappa = kappa_) `|` (OSet1B1.bad%xr + (qs - Count.countS)%xr * (p^kappa_)%xr)). 
  + by move=> &hr; apply xle_cxr_r => /> /#.
  + by conseq /(fun x =>  (OSign.sk = sk /\ OSign.kappa = kappa_) `|` (OSet1B1.bad%xr + (qs - Count.countS)%xr * (p ^ kappa_)%xr))
          (: 0%xr ==> 0%xr).
  + proc; seq 1 : #pre; 1: auto; if; 2: by auto => &hr; apply xle_cxr => />.
    inline *; wp => /=.
    seq 5 : ((i = 0 /\ oz = None) `|` #pre); 1: by auto.
    conseq /(fun x => (OSign.sk = sk/\ OSign.kappa = kappa_) `|`
             (x + OSet1B1.bad%xr + (qs - (Count.countS + 1))%xr * (p ^ kappa_)%xr)) 
          (: (OSign.sk = sk /\ OSign.kappa = kappa_ /\ i = 0) `|` 
               ((oz = None)%xr * (p^kappa_)%xr) ==> (oz = None)%xr).
    + by auto => &hr /=; apply xle_cxr => |> * /#.
    + by auto => &hr /=; case: (oz{hr} = None) => ?; apply xle_cxr => |> /#. 
    while ((OSign.sk = sk /\ OSign.kappa = kappa_ /\ i <= kappa_) `|` 
             ((oz = None)%xr * (p^(kappa_ - i))%xr)).
    + by move=> &hr /=; apply xle_cxr_r => |>; smt(expr0).
    + wp 3 => /=.
      conseq /(fun x =>  (OSign.sk = sk /\ OSign.kappa = kappa_ /\ i + 1 <= kappa_) `|`
                (x * (p ^ (kappa_ - (i + 1)))%xr))
             (: (OSign.sk = sk) `|` p%xr ==> (oz=None)%xr) => //.
      + move=> &hr /=; apply xle_cxr => |> *; split; 1: smt().
        rewrite !to_pos_pos; 1..3: smt(p_bounded expr_ge0).      
        case: (p = 0%r) => [-> /= | ?].
        + by rewrite !expr0z; case (kappa_ - i{hr} = 0).
        by rewrite -{1}(expr1 p) -exprD; smt(p_bounded).
      auto => &hr; apply xle_cxr_r => |> *; rewrite Ep_commit_dc_None /=.
      rewrite to_pos_pos;1: smt(p_bounded).
      exact sk_reject.
    by auto => &hr /=; apply xle_cxr => |> *; apply kappa_ge0.
  inline *; auto => &hr; apply xle_cxr => />.
  rewrite !to_pos_pos /=; smt(qs_ge0 expr_ge0 p_bounded).
qed.

lemma GSet1_GTrans &m : 
  Pr[Game_k(Adv, CountBound(OSet1)).main(pk,sk,kappa_) @ &m : res] <=
  Pr[Game(Adv, CountBound(OTrans)).main(pk,sk) @ &m : res] + qs%r * p ^ kappa_.
proof.
  move: (Set1B1_Set1B2 &m) (Pr_bad &m).
  by rewrite Set1_Set1B1 Set1B2_Trans_i Set1_i_Trans /#. 
qed.

end section Analysis.

end ReprogOnce.


(*******************************************************)
(*****          Main Theorem                       *****)
(*******************************************************)

(* We now compose the three main hops (still parametric in the loop
bound [kappa_] and then show that the combined bound converges as
kappa_ approaches infinity. *)
section.

declare module Adv <: Adversary {-Count, -RO, -OSign}.

declare axiom A_ll : forall (O <: Oracle{-Adv}),
  islossless O.h =>
  islossless O.sign =>
  islossless Adv(O).distinguish.

declare axiom A_bound : forall (O <: Oracle_i{-Adv, -Count}), 
  hoare [ Adv(Count(O)).distinguish : Count.countS = 0 /\ Count.countH = 0 ==> 
                                      Count.countS <= qs /\ Count.countH <= qh ].

declare op pk : PK.
declare op sk : SK.
op eps = p_max (dfst (commit sk)).
lemma eps_ge0 : 0%r <= eps by apply ge0_pmax.
declare axiom sk_reject  : bound_reject sk.

section Kappa.
declare op kappa_ : { int | 0 < kappa_ } as kappa_gt0.

local clone import ReprogAlways as RA.
local clone import ReprogOnce as R1.

lemma GSign_GSet_inf &m : 
  Pr[Game(Adv, Count(OSign)).main(pk,sk) @ &m : res] <=
    (2%r * qs%r) * p^kappa_ + (Pr[Game(Adv, Count(OTrans)).main(pk,sk) @ &m : res] +
    qs%r * (qh%r * Self.eps) / (1%r - p) + 
    qs%r * Self.eps * ((qs%r + 1.0)/ (2.0 * (1.0 - p)^2) + qh%r / (1.0 - p))).
proof.
  pose hop1 := (qs%r * p ^ kappa_ + 
                qs%r * eps * ((qs%r + 1%r) / (2%r * (1%r - p) ^ 2) + qh%r / (1%r - p))).
  pose hop2 := qs%r * (qh%r * eps) / (1%r - p).
  pose hop3 := qs%r * p^kappa_.
  pose GA := Pr[Game(Adv, Count(OTrans)).main(pk,sk) @ &m : res].
  apply (ler_trans (GA + hop3 + hop2 + hop1)); last smt().
  have X := (GSign_GSet Adv A_bound pk sk sk_reject kappa_ kappa_gt0 &m).
  apply (ler_trans _ _ _ X) => {X}; rewrite ler_add2r.
  have X := GSet_GSet1 Adv A_bound A_ll pk sk sk_reject kappa_ kappa_gt0 &m.
  apply (ler_trans _ _ _ X) => {X}; rewrite ler_add2r.
  have X := (GSet1_GTrans Adv A_bound A_ll pk sk sk_reject kappa_ kappa_gt0 &m).
  apply (ler_trans _ _ _ X) => {X}; rewrite ler_add2r.
  by rewrite /GA (Pr_Count_CountBound Adv A_bound pk sk sk_reject OTrans &m).
qed.
end section Kappa.

(* As a (almost) final step, we remove the dependency on [kappa] by showing
that the bound converges as [kappa] is increased to infinity *)
lemma GSign_GTrans_aux &m :  
  Pr[Game(Adv, Count(OSign)).main(pk,sk) @ &m : res] <= 
   Pr[Game(Adv, Count(OTrans)).main(pk,sk) @ &m : res] + 
    2%r * qs%r * qh%r * eps / (1%r - p) + 
    qs%r * eps * (qs%r + 1.0) / (2.0 * (1.0 - p)^2).
proof.
  pose hop1 := qs%r * eps * ((qs%r + 1.0)/ (2.0 * (1.0 - p)^2) + qh%r / (1.0 - p)).
  pose hop2 := qs%r * (qh%r * eps) / (1%r - p).
  pose GA := Pr[Game(Adv, Count(OTrans)).main(pk,sk) @ &m : res].
  have hp : -1%r < p < 1%r by smt(p_bounded).
  apply (ler_trans (GA + hop2 + hop1)); last by smt().
  have hc : RealSeq.converge (fun (x : int) => 2%r * qs%r * p ^ x).
  + by apply/cnvZ/cnv_pow/hp. 
  apply (ler_trans (lim (fun kappa => 2%r * qs%r * p^kappa + (GA + hop2 + hop1)))).
  + apply (geC_lim_from 1) => /=.
    + by move=> kappa_ hk; apply (GSign_GSet_inf kappa_ _ &m) => /#. 
    apply cnvD => //; apply cnvC.
  by rewrite limD 1:// 1:cnvC limZ lim_pow //= limC.
qed.

(* lastly, we remove the counting wrappers *)
lemma GSign_GSet1 &m : 
  Pr[Game(Adv, OSign).main(pk,sk) @ &m : res] <= 
   Pr[Game(Adv, OTrans).main(pk,sk) @ &m : res] + 
    2%r * qs%r * qh%r * eps / (1%r - p) + 
    qs%r * eps * (qs%r + 1.0) / (2.0 * (1.0 - p)^2).
proof.
have -> : Pr[Game(Adv, OSign).main(pk,sk) @ &m : res] = 
          Pr[Game(Adv, Count(OSign)).main(pk,sk) @ &m : res].
- byequiv => //; proc;call (: ={RO.m, OSign.sk}). 
  + proc*. inline Count(OSign).h. wp. call(: ={RO.m}). sim. auto.
  + proc. inline OSign.sign. wp. by sim. 
  inline*; auto => />.
have -> : Pr[Game(Adv, OTrans).main(pk,sk) @ &m : res] = 
          Pr[Game(Adv, Count(OTrans)).main(pk,sk) @ &m : res].
- byequiv => //; proc;call (: ={RO.m, OSign.sk}). 
  + proc*. inline Count(OTrans).h. wp. call(: ={RO.m}). sim. auto.
  + proc. inline OTrans.sign. wp. by sim. 
  inline*; auto => />.
exact (GSign_GTrans_aux &m).
qed.

end section.
