(* Axiomatization of the Ring Zq[X]/(X^n + 1) and the highBits and
lowBits operations used in Dilithium *)

require import AllCore IntDiv Distr.
require Subtype.

pred image (f : 'a -> 'b) y = exists x, f x = y.
pred injective_in P (f : 'a -> 'b) = 
  forall x y, P x => P y => f x = f y => x = y.

(* Modulo *)
op q : {int | prime q} as prime_q. 

(* Poly degrees *)
op n : {int | 0 < n} as gt0_n.

(* Polynomial ring â„¤q[X]/(X^n +1 ) *)
type Rq.

clone import Ring.ComRing as RqRing with type t <= Rq.

op cnorm : Rq -> int.             (* infinity norm (after centered reduction modulo) *)
op l1_norm : Rq -> int.           (* sum over absolute values                        *)

(* TOTHINK: If [high = Rq] is a problem, we either need to have a
ComRing structure on high or use lists rather than vectors to pass
[w1] around *)

op [lossless full uniform] dRq : Rq distr. 

lemma dRq_funi : is_funiform dRq by smt(dRq_fu dRq_uni).

op [lossless uniform] dRq_ : int -> Rq distr.
axiom supp_dRq x a : x \in dRq_ a <=> cnorm x <= a.

op [lossless uniform] dC  : int -> Rq distr.
axiom supp_dC c a : c \in dC a <=> cnorm c <= 1 /\ l1_norm c = a.

axiom cnorm_ge0 (r : Rq) : 0 <= cnorm r.
axiom cnormN (r : Rq) : cnorm (-r) = cnorm r.

(* high/low-bits operations (fixed modulus) *)

theory Flex.

type high.
op lowBits : Rq -> int -> Rq. 
op highBits : Rq -> int -> high.
op shift    : high -> int ->  Rq.

axiom high_lowP x a : shift (highBits x a) a + lowBits x a = x.

axiom hide_low r s b a : 
  cnorm s <= b => cnorm (lowBits s a) < a %/ 2 - b =>
  highBits (r + s) a = highBits r a.

axiom lowbit_small r a :
  cnorm (lowBits r a) <= a %/ 2. (* TOTHINK: +1 ? *)

axiom shift_inj a : 
  injective_in (image (transpose highBits a)) (transpose shift a).

end Flex.
    
abstract theory HighLow.
op alpha : int. 

axiom ge2_alpha : 2 <= alpha.
axiom alpha_halfq_le : alpha <= q %/ 2.
axiom even_alpha : 2 %| alpha.
axiom alpha_almost_divides_q : alpha %| (q - 1).

clone import Subtype as S with 
  type T <- Flex.high,
  pred P <- image (transpose Flex.highBits alpha).

type high = sT.

op highBits (r : Rq) = insubd (Flex.highBits r alpha).
op lowBits (r : Rq) = Flex.lowBits r alpha.
op shift (h : high) = Flex.shift (val h) alpha.

lemma high_lowP x : shift (highBits x) + lowBits x = x.
proof. 
by rewrite /shift /highBits /lowBits insubdK 1:/# Flex.high_lowP.
qed.

lemma hide_low r s b : 
  cnorm s <= b => cnorm (lowBits s) < alpha %/ 2 - b =>
  highBits (r + s) = highBits r.
proof.
by move => *; rewrite /highBits (Flex.hide_low r s b).
qed.

lemma lowbit_small r :
  cnorm (lowBits r) <= alpha %/ 2. 
proof. by rewrite /lowsBits (Flex.lowbit_small). qed.

lemma shift_inj : injective shift. 
proof.
move => h1 h2; have S := Flex.shift_inj alpha _ _ (valP h1) (valP h2).
by move/S; apply val_inj.
qed.

end HighLow.
