require import AllCore Distr DBool PROM List StdOrder FelTactic Xreal.
(*---*) import StdBigop.Bigreal.BRA.

require import Dexcepted.
require import Real RealSeries RealSeq.
require import DistrExtras.
require (*--*) Reprog_inf.

import SmtMap RealOrder.

(* Define some necessary abstract stuff *)
clone include Reprog_inf.
  import RO.
  

(* Moving RO.set outside while-loop *)
module OSet1_inf : Oracle_i = { 
  import var OReal
  include var OSet[init, h]

  proc sign(m: M) = {
    var w, st, c, oz;

    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;
    oz <- None;
    while(oz = None) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
    }
    RO.set((w, m), c);
    return Some (w, c, oget oz);
  }
}.

(* This lemma should be moved to EC *)
lemma hybrid_sum (f: int -> real) (m n:int) : m <= n =>
  f(n) - f(m) = bigi predT (fun i => f(i+1) - f(i)) m n.
proof.
  move=> /IntOrder.ler_eqVlt [<<- | hmn].
  + by rewrite big_geq 1://; ring.
  rewrite -sumrB (big_ltn m n f) 1:// /=.
  have heq: n = n - 1 + 1 by ring.
  rewrite heq (big_int_recr (n-1) m) 1:/# -heq /=; ring.
  rewrite (big_reindex _ _ (fun x=> x - 1) (fun x=> x + 1) (range m (n - 1))) //.
  have ->: (transpose Int.(+) 1) = ((+) 1).
  + by apply: fun_ext=> x; ring.
  have ->: predT \o transpose Int.(+) (-1) = predT by done.
  by rewrite /(\o) /= -(range_addl m n 1).
qed. 

abstract theory Analysis1.

module OSet1 : Oracle_i = {
  import var OReal
  include var OSet[init, h]

  proc sign(m: M) = {
    var w, st, c, oz, i;

    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;

    i <- 0;
    oz <- None;
    while(oz = None /\ i < OReal.kappa) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
      i <- i + 1;
    }
    if(oz <> None)
      RO.set((w, m), c);
    return if oz <> None then Some (w, c, oget oz) else None;
  }
}.

module type Oracle_i_i = {
  include Oracle
  proc init(sk_i : SK, i:int) : unit
 }.

module type Oracle_i_ij = {
  include Oracle
  proc init(sk_i : SK, i:int, j:int) : unit
 }.

module Oi : Oracle_i_i = {
  var sk : SK
  var i_ : int
  var j_ : int
  var j_end : bool
  var wo : W option
  var w_ : W
  var logh : W list

  var countS : int
  var countH : int

  proc init(sk_i:SK, i_i:int) = { 
    i_ <- i_i;
    sk <- sk_i;
    countS <- 0;
    countH <- 0;
    logh <- [];
  }

  proc h(w : W, m : M) : C = { 
    var y;
    y <- witness;
    if (countH < qh) {
      y <@ RO.get((w, m));
      countH <- countH + 1;
      logh <- w::logh;
    }
    return y;
  }

  proc sign_l(m : M) = {
    var w, st, c, oz, j;
    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;

    j <- 0;
    oz <- None;
    while(oz = None /\ j < OReal.kappa) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
      RO.set((w, m), c);
      j <- j + 1;
    }
    return if oz <> None then Some (w, c, oget oz) else None;
  }

  proc sign_r(m : M) = { 
    var w, st, c, oz, j;

    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;

    j <- 0;
    oz <- None;
    while(oz = None /\ j < OReal.kappa) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
      RO.m <- (oz <> None) ? RO.m.[(w,m) <- c] : RO.m;
      j <- j + 1;
    }
    return if oz <> None then Some (w, c, oget oz) else None;
  }    

  proc sign(m : M) = {
    var r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_) r <@ sign_l(m);
      else r <@ sign_r(m);
      countS <- countS + 1;
    }
    return r;
  }

}.

module Oij : Oracle_i_ij = {
  include var Oi [-init, sign]

  proc init(sk_i:SK, i_i:int, j_i:int) = { 
    i_ <- i_i;
    j_ <- j_i;
    j_end <- false;
    sk <- sk_i;
    countS <- 0;
    countH <- 0;
    wo <- None;
    w_ <- witness;
    logh <- [];
  }

  proc sign_i_l (m:M) = {
    var w, st, c, oz;
    (w, st) <$ commit sk;
    c <$ dC;
    oz <- respond sk st c;
    RO.set((w, m), c);
    return (w, c, oz);
  }

  proc sign_i_j (m:M) = {
    var st, c, oz;
    (w_, st) <$ commit sk;
    c <$ dC;
    oz <- respond sk st c;
    (* The !j_end and wo = None seems stupid but it is important to be able prove preservation of bads (for the two next bad event *)
    wo <- (!j_end /\ wo = None /\ oz = None) ? Some w_ : wo;  
    j_end <- true;
    RO.m <- (oz <> None) ? RO.m.[(w_,m) <- c] : RO.m;
    return (w_, c, oz);
  }

  proc sign_i_r (m:M) = {
    var w, st, c, oz;
    (w, st) <$ commit sk;
    c <$ dC;
    oz <- respond sk st c;
    RO.m <- (oz <> None) ? RO.m.[(w,m) <- c] : RO.m;
    return (w, c, oz);
  }

  proc sign_i (m:M): (W * C * Z) option = {
    var w, c, oz, j;
    w <- witness;
    c <- witness;
    j <- 0;
    oz <- None;
    while(oz = None /\ j < OReal.kappa) {
      if (j < j_) (w, c, oz) <@ sign_i_l (m);
      else { if (j_ = j) (w, c, oz) <@ sign_i_j (m); 
      else (w, c, oz) <@ sign_i_r (m); }
      j <- j + 1;
    }
    return if oz <> None then Some (w, c, oget oz) else None;
  }
  
  proc sign(m:M) = {
    var r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_) r <@ sign_l(m);
      else { if (i_ = countS) r <@ sign_i(m);
      else r <@ sign_r(m); }
      countS <- countS + 1;
    }
    return r;
  }

}.

module Hi (Adv: Adversary) (O: Oracle_i_i) = {
  proc main(kappa_:int, i_i:int) = {
    var b, pk, sk;
    OReal.kappa <- kappa_;
    (pk, sk) <$ keygen;
    RO.init();
    O.init(sk, i_i);
    b <@ Adv(O).distinguish(pk);
    return b;
  }
}.

module Hij (Adv: Adversary) (O: Oracle_i_ij) = {
  proc main(kappa_:int, i_i:int, j_i:int) = {
    var b, pk, sk;
    OReal.kappa <- kappa_;
    (pk, sk) <$ keygen;
    RO.init();
    O.init(sk, i_i, j_i);
    b <@ Adv(O).distinguish(pk);
    return b;
  }
}.

section Analysis.

declare module Adv <: Adversary {-Count, -RO, -OReal, -Oi}.

declare axiom A_bound : forall (O <: Oracle_i{-Adv, -Count}), 
  hoare [ Adv(Count(O)).distinguish : Count.countS = 0 /\ Count.countH = 0 ==> 
                                      Count.countS <= qs /\ Count.countH <= qh ].

declare axiom A_ll : forall (O <: Oracle{-Adv}),
  islossless O.h =>
  islossless O.sign =>
  islossless Adv(O).distinguish.

declare op kappa_ : int.
declare axiom kappa_gt0 : 0 < kappa_.

lemma kappa_ge0 : 0 <= kappa_ 
by smt(kappa_gt0).

local lemma GSet_Hi &m : 
  Pr[Game_k(Adv, CountBound(OSet)).main(kappa_) @ &m : res] = 
  Pr[Hi(Adv, Oi).main(kappa_, qs) @ &m : res].
proof.
  byequiv => //; proc; inline{1} Game(Adv, CountBound(OSet)).main; wp.
  call (: ={RO.m, OReal.kappa} /\ OReal.sk{1} = Oi.sk{2} /\ Oi.i_{2} = qs /\ 
          Count.countS{1} = Oi.countS{2} /\ Count.countH{1} = Oi.countH{2}).
  + by sim />. 
  + proc; sp; if => //; rcondt{2} ^if; auto; sim />.
  inline *; auto.
qed.
  
local lemma GSet1_Hi &m : 
  Pr[Game_k(Adv, CountBound(OSet1)).main(kappa_) @ &m : res] = 
  Pr[Hi(Adv, Oi).main(kappa_, 0) @ &m : res].
proof.
  byequiv => //; proc; inline Game(Adv, CountBound(OSet1)).main; wp.
  call (: ={RO.m, OReal.kappa} /\ OReal.sk{1} = Oi.sk{2} /\ (Oi.i_ <= Oi.countS){2} /\
          Count.countS{1} = Oi.countS{2} /\ Count.countH{1} = Oi.countH{2}).
  + sim />.
  + proc; sp; if => //.
    rcondf{2} ^if; 1: by auto => /#.
    wp; conseq (: y{1} = r{2} /\ OReal.sk{1} = Oi.sk{2} /\ ={RO.m}); 1: smt().
    inline *; wp.
    by while (={w, c, oz, OReal.kappa} /\ i{1} = j{2} /\ m{1} = m0{2} /\ OReal.sk{1} = Oi.sk{2} /\
           RO.m{2} = (if oz <> None then RO.m.[(w, m) <- c] else RO.m){1}); auto.
  by inline *; auto.
qed.

local lemma GSet_GSet1_aux &m: 
  Pr[Game_k(Adv, CountBound(OSet)).main(kappa_) @ &m : res] - 
  Pr[Game_k(Adv, CountBound(OSet1)).main(kappa_) @ &m : res] = 
     bigi predT (fun (i : int) => Pr[Hi(Adv, Oi).main(kappa_, i+1) @ &m : res] - Pr[Hi(Adv, Oi).main(kappa_, i) @ &m : res]) 0 qs.
proof.
  rewrite GSet_Hi GSet1_Hi.
  by have /= -> := (hybrid_sum (fun i => Pr[Hi(Adv, Oi).main(kappa_, i) @ &m : res]) 0 qs qs_ge0).
qed.

(* We focus on  Pr[Hi(Adv, Oi).main(kappa_, i+1) @ &m : res] - Pr[Hi(Adv, Oi).main(kappa_, i) @ &m : res] *)
section I.

declare op i : int.
declare axiom i_bounded : 0 <= i < qs.

local lemma Hi_Hij &m : 
   Pr[Hi(Adv, Oi).main(kappa_, i) @ &m : res] = 
   Pr[Hij(Adv,Oij).main(kappa_, i, 0) @ &m : res].
proof.
  byequiv => //; proc.
  call (: ={Oi.i_, Oi.sk, Oi.countS, Oi.countH, RO.m, OReal.kappa} /\ Oi.j_{2} = 0).
  + by sim />.
  + proc; sp; if => //; wp; if => //; 1: by sim/>.
    if{2}; 2: by sim/>.
    inline Oi.sign_r Oij.sign_i; wp.
    while (={m0, w, c, j, oz, RO.m, Oi.sk, OReal.kappa} /\ Oi.j_{2} <= j{2}); last by auto.
    rcondf{2} ^if; 1: by auto => /#.
    by inline *; if{2}; auto => /> /#.
  by inline *; auto.   
qed.

local lemma Hi1_Hij &m : 
   Pr[Hi(Adv, Oi).main(kappa_, i+1) @ &m : res] = 
   Pr[Hij(Adv,Oij).main(kappa_, i, kappa_) @ &m : res].
proof.
  byequiv => //; proc.
  call (: ={Oi.sk, Oi.countS, Oi.countH, RO.m, OReal.kappa} /\ Oi.i_{1} = Oi.i_{2} + 1 /\ Oi.j_{2} = OReal.kappa{2}).
  + by sim />.
  + proc; sp; if => //; wp; if{2}.
    + rcondt{1} ^if; 1: by auto => /#.
      by sim />.
    if{2}; 2: by rcondf{1} ^if; [auto=> /# | sim />].
    rcondt{1} ^if; 1: by auto => /#.  
    inline Oi.sign_l Oij.sign_i Oij.sign_i_l; wp.
    while (={m0, w, c, oz, RO.m, Oi.sk, j, OReal.kappa} /\ Oi.j_{2} = OReal.kappa{2}); 2: by auto.
    by inline RO.set; rcondt{2} ^if; auto.
  by inline *; auto.
qed.

local lemma HiHi1 &m : 
  Pr[Hi(Adv, Oi).main(kappa_, i+1) @ &m : res] - Pr[Hi(Adv, Oi).main(kappa_, i) @ &m : res] =
  bigi predT (fun (j : int) => Pr[Hij(Adv, Oij).main(kappa_, i, j+1) @ &m : res] - Pr[Hij(Adv, Oij).main(kappa_, i, j) @ &m : res]) 0 kappa_.
proof.
  rewrite Hi_Hij Hi1_Hij.
  have /= -> // := (hybrid_sum (fun j => Pr[Hij(Adv, Oij).main(kappa_, i, j) @ &m : res]) 0 kappa_).
  smt(kappa_gt0).
qed.

(* We focus on Pr[Hij(Adv, Oij).main(kappa_, i, j+1) @ &m : res] - Pr[Hij(Adv, Oij).main(kappa_, i, j) @ &m : res] *)
section J.

declare op j : int.
declare axiom j_bounded : 0 <= j < kappa_.

op is_update (m1 m2: (W * M, C)fmap) (w:W) = 
  exists m c, m1 = m2.[(w,m) <- c].

lemma is_update_set m1 m2 w k c: is_update m1 m2 w => is_update m1.[k<-c] m2.[k<-c] w.
proof.
  move=> /> m c'; case: (k = (w, m)) => [-> | ? ]; [exists m c | exists m c']; 
    apply fmap_eqP; smt(get_setE).
qed.

local lemma Oij_sign_ll : islossless Oij.sign.
proof.
  islossless. 
  + while true (OReal.kappa - j); 2: by auto => /#.
    by move=> z; wp; conseq (:true); 1: smt(); islossless.
  + while true (OReal.kappa - j); 2: by auto => /#.
    by move=> z; wp; conseq (:true); 1: smt(); islossless.
  while true (OReal.kappa - j); 2: by auto => /#.
  by move=> z; wp; conseq (:true); 1: smt(); islossless.
qed.

local lemma bad &m : 
  Pr[Hij(Adv, Oij).main(kappa_, i, j+1) @ &m : res] <= 
    Pr[Hij(Adv, Oij).main(kappa_, i, j) @ &m : res] + 
    Pr[Hij(Adv, Oij).main(kappa_, i, j) @ &m : exists w, w \in Oi.logh /\ Oi.wo = Some w].
proof.
  byequiv (: _ ==> !(exists w, w \in Oi.logh /\ Oi.wo = Some w){2} => ={res}) => //; last first.
  + by move=> &1 &2 h1 /h1 ->.
  proc.
  call (: (exists w, w \in Oi.logh /\ Oi.wo = Some w),
          (Oi.countS <= Oi.i_ => !Oi.j_end /\ Oi.wo = None){2} /\
          (forall w, w \in Oi.logh => exists m, (w, m) \in RO.m){2} /\
          ={Oi.countS, Oi.countH, Oi.i_, Oi.sk, Oi.logh, OReal.kappa} /\ Oi.j_{1} = Oi.j_{2} + 1 /\ 0 <= Oi.j_{2} < OReal.kappa{2} /\
          if Oi.wo{2} = None then ={RO.m}
          else is_update RO.m{1} RO.m{2} (oget Oi.wo{2})).
  + apply A_ll.
  + by proc; inline *; sp; if => //; auto => |>; smt(is_update_set get_setE).
  + by move=> *; islossless.
  + by move=> _; proc; inline *; sp; if => //; auto => />; smt( dC_ll get_setE).
  + proc; sp; if => //; wp.
    if => //.
    + conseq (: _ ==> ={RO.m, r} /\ (forall w, w \in Oi.logh => exists m, (w, m) \in RO.m){2}); 1: smt().
      inline *; wp.
      while (={m0, w, c, j, oz, RO.m, Oi.sk, OReal.kappa}  /\ (forall w, w \in Oi.logh => exists m, (w, m) \in RO.m){2}).
      + by auto => />; smt(get_setE).
      by auto => /> /#.
    if => //; last first.
    + inline *; wp.
      while(={m0,w,c,j,oz, Oi.sk, OReal.kappa} /\ 
            (forall w, w \in Oi.logh => exists m, (w, m) \in RO.m){2} /\
            if Oi.wo{2} = None then ={RO.m}
            else is_update RO.m{1} RO.m{2} (oget Oi.wo{2})).
      + by auto => |>; smt(is_update_set get_setE).
      by auto => |> /#. 
    inline Oij.sign_i RO.set; wp.
    while( (j{1} <= Oi.j_{2} => !Oi.j_end{2} /\ Oi.wo{2} = None) /\     
              ={Oi.countS, Oi.i_, Oi.sk, j, m0, c, oz, w, OReal.kappa} /\ Oi.j_{1} = Oi.j_{2} + 1 /\ 0 <= Oi.j_{2} /\
             (forall w, w \in Oi.logh => exists m, (w, m) \in RO.m){2} /\
             if (j <= Oi.j_ \/ Oi.wo = None){2} then ={RO.m} else is_update RO.m{1} RO.m{2} (oget Oi.wo{2})).
    + wp; if{2}.
      + rcondt{1} ^if; 1: by auto => /#.
        by inline *; auto => |>; smt(get_setE).
      if{2}; last first.
      + rcondf{1} ^if; 1: by auto => /#.
        if{1}; inline *; auto => |> *; smt(get_setE is_update_set).
      rcondt{1} ^if; 1: by auto => /#.
      by inline *; auto => />; smt(is_update_set get_setE).
    by auto => /> /#.
  + by move=> _ _; apply Oij_sign_ll.
  + move=> _. 
    conseq Oij_sign_ll 
      (:(exists (w : W), (w \in Oi.logh) /\ Oi.wo = Some w) ==> 
        (exists (w : W), (w \in Oi.logh) /\ Oi.wo = Some w)) => //; 1: smt(). 
    proc; sp; if => //; 2: by auto => />.
    inline *; wp; if.
    + wp; while (exists (w4 : W), (w4 \in Oi.logh) /\ Oi.wo = Some w4); auto; smt(get_setE).
    if; wp; while (exists (w4 : W), (w4 \in Oi.logh) /\ Oi.wo = Some w4); auto; 2..4: smt(get_setE).
    if; 1: by auto; smt(get_setE).
    if; auto; smt(get_setE).
  inline *; auto; smt (j_bounded).
qed.

local module Oij_split : Oracle_i_ij = {
  import var Oi
  include Oij [-sign, sign_i]

  proc sign_i (m:M): (W * C * Z) option = {
    var w, c, oz, j;
    w <- witness;
    c <- witness;
    j <- 0;
    oz <- None;
    while(oz = None /\ j < j_) {
      (w, c, oz) <@ sign_i_l (m);
      j <- j + 1;
    }
    j <- j_; (* this is ensured if oz = None *)
    if (oz = None /\ j_ < OReal.kappa) (w, c, oz) <@ sign_i_j (m); 
    j <- j_ + 1;
    while (oz = None /\ j < OReal.kappa) {
       (w, c, oz) <@ sign_i_r (m); 
      j <- j + 1;
    }
    return if oz <> None then Some (w, c, oget oz) else None;
  }

  proc sign(m:M) = {
    var r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_) r <@ sign_l(m);
      else { if (i_ = countS) r <@ sign_i(m);
      else r <@ sign_r(m); }
      countS <- countS + 1;
    }
    return r;
  }

}.

local lemma Oij_Oij_split &m : 
  Pr[Hij(Adv, Oij).main(kappa_, i, j) @ &m : exists w, w \in Oi.logh /\ Oi.wo = Some w] = 
  Pr[Hij(Adv, Oij_split).main(kappa_, i, j) @ &m : exists w, w \in Oi.logh /\ Oi.wo = Some w].
proof.
  byequiv => //; proc.
  call (: ={glob Oi, OReal.kappa} /\ 0 <= Oi.j_{2} < OReal.kappa{2}); last by inline *; auto; smt(j_bounded).
  + by sim />.
  proc; sp; if => //.
  if => //; 1: by sim />.
  if => //; 2: by sim />.
  inline Oij.sign_i Oij_split.sign_i.
  sim />.
  splitwhile{1} ^while : (j < Oi.j_). 
  seq 6 6 : (={glob Oi, OReal.kappa, m0, w, c, j, oz} /\ 
              (0 <= Oi.j_ < OReal.kappa /\ (oz = None => j = Oi.j_)){2}).
  + while (={glob Oi, OReal.kappa, m0, w, c, j, oz} /\ (j <= Oi.j_ /\ 0 <= Oi.j_ < OReal.kappa){2}).
    + rcondt{1} ^if; 1: by auto. 
      by wp; conseq (: ={glob Oi, w, c, oz}); [smt() | sim].
    by auto => /> /#.
  sp; if{2}.
  + rcondt{1} ^while; 1: by auto => /#.
    rcondf{1} ^if; 1: by auto => /#.
    rcondt{1} ^if; 1: by auto => /#.
    while (={glob Oi, OReal.kappa, m0, w, c, j, oz} /\ (Oi.j_ < j){2}).
    + rcondf{1} ^if; 1: by auto => /#.
      rcondf{1} ^if; 1: by auto => /#.
      by wp; conseq (: ={RO.m, w, c, oz}); [ smt() | sim].
    wp; conseq (: ={RO.m, w, c, oz, Oi.wo, Oi.w_, Oi.j_end} /\ j{1} = Oi.j_{2}); 1: smt().
    by sim => />.
  rcondf{2} ^while; 1: by auto => />.
  by rcondf{1} ^while; auto => />.
qed.

local module Oij_bad : Oracle_i_ij = {
  import var Oi
  include var Oij [-sign, sign_i, sign_i_j]

  proc sign_i_j (m:M) : W * C * Z option = {
    var st, c;
    (w_, st) <$ commit sk;
    c <$ dC;
    j_end <- true;
    return (witness, c, None);
  }

 proc sign_i (m:M): (W * C * Z) option = {
    var w, c, oz, j;
    w <- witness;
    c <- witness;
    j <- 0;
    oz <- None;
    while(oz = None /\ j < j_) {
      (w, c, oz) <@ sign_i_l (m);
      j <- j + 1;
    }
    j <- j_; (* this is ensured if oz = None *)
    if (oz = None /\ j_ < OReal.kappa) (w, c, oz) <@ sign_i_j (m); 
    j <- j_ + 1;
    while (oz = None /\ j < OReal.kappa) {
       (w, c, oz) <@ sign_i_r (m); 
      j <- j + 1;
    }
    return if oz <> None then Some (w, c, oget oz) else None;
  }

  proc sign(m:M) = {
    var r;
    r <- witness;
    if (countS < qs) { 
      if (countS < i_) r <@ sign_l(m);
      else { if (i_ = countS) r <@ sign_i(m);
      else r <@ sign_r(m); }
      countS <- countS + 1;
    }
    return r;
  }

}.

local lemma Oij_split_Oij_bad &m : 
   Pr[Hij(Adv, Oij_split).main(kappa_, i, j) @ &m : exists w, w \in Oi.logh /\ Oi.wo = Some w] <= 
   Pr[Hij(Adv, Oij_bad).main(kappa_, i, j) @ &m : Oi.j_end /\ Oi.w_ \in Oi.logh].
proof. 
  byequiv => //; symmetry; proc.
  call (: Oi.j_end /\ Oi.wo = None,
          (Oi.countS <= Oi.i_ => !Oi.j_end /\ Oi.wo = None){2} /\ 
          ={Oi.logh, RO.m, Oi.sk, Oi.countS, Oi.countH, Oi.i_, Oi.j_, Oi.j_end, Oi.w_, OReal.kappa} /\ 
          0 <= Oi.j_{1} < OReal.kappa{2} /\ 
          (Oi.wo <> None => Oi.j_end /\ Oi.wo = Some Oi.w_){2}).
  + apply A_ll.
  + by proc; sp; if => //; inline *; auto.
  + by move=> *; islossless.
  + by move=> _; proc; sp; if => //; inline *; auto => />; smt( dC_ll get_setE).    
  + proc; sp; if => //; wp; if => //.
    + by conseq (: ={r, RO.m}); 1: smt(); sim.
    if => //; wp; last by conseq (: ={r, RO.m}); 1: smt(); sim.
    inline Oij_bad.sign_i Oij_split.sign_i.
    seq 7 7 : 
       ((!Oi.j_end /\ Oi.wo = None){2} /\ 0 <= Oi.j_{1} < OReal.kappa{2} /\ Oi.i_{1} = Oi.countS{1} /\
         ={Oi.logh, RO.m, Oi.sk, Oi.countS, Oi.countH, Oi.i_, Oi.j_, Oi.j_end, Oi.w_, OReal.kappa, m0, w, c, j, oz}).
    + by conseq (: ={RO.m, m0, w, c, j, oz}); [ smt() | sim].
    inline Oij_bad.sign_i_j Oij_split.sign_i_j.
    seq 2 2 : ( !(Oi.j_end{2} /\ Oi.wo{2} = None) =>
                    (={Oi.logh, RO.m, Oi.sk, Oi.countS, Oi.countH, Oi.i_, Oi.j_, Oi.j_end, Oi.w_, OReal.kappa, m0, c, j, oz} /\  
                     (Oi.j_end{2} => oz{1} = None) /\ 0 <= Oi.j_{1} < OReal.kappa{1} /\
                     (Oi.wo{2} <> None => Oi.j_end{2} /\ Oi.wo{2} = Some Oi.w_{2}) /\
                     Oi.i_{1} = Oi.countS{1}) /\
                     (oz{1}<> None => ={w})).
    + by if; auto => /> /#.
    (* case on if bad is set *)
    case: (Oi.j_end{2} /\ Oi.wo{2} = None).
    + conseq (: true) => />.
      wp; while{1} true (OReal.kappa{1} -j{1}).
      + by move=> _ z; wp; conseq (:true); [smt() | islossless].
      while{2} true (OReal.kappa{2} -j{2}); last by auto => /#.
      by move=> _ z; wp; conseq (:true); [smt() | islossless].
    wp; while (={j, oz, c, m0, RO.m, Oi.sk, OReal.kappa} /\ (oz{1} <> None => ={w})).
    + by inline *; auto => /> /#.
    by skip => /> /#.
  + move=> *; islossless.
    + while true (OReal.kappa - j); 2: by auto => /#.
      by move=> z; wp; conseq (:true); 1: smt(); islossless.
    + while true (OReal.kappa - j); 2: by auto => /#.
      by move=> z; wp; conseq (:true); 1: smt(); islossless.
    + while true (Oi.j_ - j); 2: by auto => /#.
      by move=> z; wp; conseq (:true); 1: smt(); islossless.
    while true (OReal.kappa - j); 2: by auto => /#.
    by move=> z; wp; conseq (:true); 1: smt(); islossless.
  + move=> _; proc; sp; if => //; wp; if.
    + conseq />; islossless.
      while true (OReal.kappa - j); 2: by auto => /#.
      by move=> z; wp; conseq (:true); 1: smt(); islossless.
    if; last first.
    + conseq />; islossless.
      while true (OReal.kappa - j); 2: by auto => /#.
      by move=> z; wp; conseq (:true); 1: smt(); islossless.
    inline *; wp.
    conseq (: true ==> true) (: Oi.j_end /\ Oi.wo = None ==> Oi.j_end /\ Oi.wo = None) => //.
    + while true => //.
      wp; seq 7 : (Oi.j_end /\ Oi.wo = None) => //.
      + by conseq />.
      by if; auto => /#.
    islossless.
    + while true (OReal.kappa - j); 2: by auto => /#.
      by move=> z; wp; conseq (:true); 1: smt(); islossless.
    while true (Oi.j_ - j); 2: by auto => /#.
    by move=> z; wp; conseq (:true); 1: smt(); islossless.
  inline *; auto => />; smt(j_bounded).
qed.

local clone PROM.FullRO as ROsk with
  type in_t <= SK, 
  type out_t <= W * ST,
  op dout <= commit,
  type d_in_t <= int * int * int,
  type d_out_t <= bool
proof *.

local module Oij_LE (H : ROsk.RO) : Oracle_i_ij = {
  import var Oi
  include var Oij [-sign, sign_i, sign_i_j]

  (* i_done is used when we do fel *)
  var i_done : bool

  proc sign_i (m:M): (W * C * Z) option = {
    var w, c, oz, j;
    if (!i_done /\ valid_sk Oi.sk) {
    w <- witness;
    c <- witness;
    j <- 0;
    oz <- None;
    while(oz = None /\ j < Analysis1.j) {
      (w, c, oz) <@ sign_i_l (m);
      j <- j + 1;
    }
    j <- j_; (* this is ensured if oz = None *)
    if (oz = None /\ j_ < OReal.kappa) { 
        H.sample(sk);
        c <$ dC;
        j_end <- true;
        w <- witness;
        oz <- None;
    }
    j <- j_ + 1;
    while (oz = None /\ j < OReal.kappa) {
       (w, c, oz) <@ sign_i_r (m); 
      j <- j + 1;
    }
    i_done <- true;
    }
    return if oz <> None then Some (w, c, oget oz) else None;
  }

  proc sign(m:M) = {
    var r;
    r <- witness;
    if (countS < qs) {
      if (countS < i_) r <@ sign_l(m);
      else { if (i_ = countS) r <@ sign_i(m);
      else r <@ sign_r(m); }
      countS <- countS + 1;
    }
    return r;
  }
}.

local module D (H :  ROsk.RO) = {

  proc distinguish1 (kappa_:int, i_i:int, j_i:int) = {
    var b, pk, sk;
    OReal.kappa <- kappa_;
    (pk, sk) <$ keygen; Oij_LE.i_done <- false;
    RO.init();
    H.init();
    Oij_LE(H).init(sk, i_i, j_i);
    b <@ Adv(Oij_LE(H)).distinguish(pk);
  }

  proc distinguish (kappa_:int, i_i:int, j_i:int) = {
    var st;
    distinguish1 (kappa_, i_i, j_i);
    (Oi.w_, st) <@ H.get(Oi.sk);
    return (Oi.j_end /\ b2i Oij_LE.i_done <= 1) /\ Oi.w_ \in Oi.logh;
  }

}.

local lemma Oij_bad_DRO &m : 
  Pr[Hij(Adv, Oij_bad).main(kappa_, i, j) @ &m : Oi.j_end /\ Oi.w_ \in Oi.logh] = 
  Pr[D(ROsk.RO).distinguish(kappa_, i, j) @ &m : res].
proof.
  byequiv (: ={glob Adv, arg} /\ i_i{1} = i /\ j_i{1} = j ==> _) => //.
  proc; wp; inline D(ROsk.RO).distinguish1. sp 1 4.
  seq 4 6: (={Oi.j_end, Oi.logh} /\
             (Oi.j_end => exists st, ROsk.RO.m.[Oi.sk] = Some (Oi.w_{1}, st)){2});
    last first.
  + case: (Oi.j_end{2}).
    + by inline *; rcondf{2} ^if; auto => /> /#.
    by call{2} (:true ==> true); [islossless | auto].
  call (: ={RO.m, Oi.j_end, Oi.j_, Oi.logh, Oi.countH, Oi.countS, Oi.countH, Oi.sk, Oi.i_, OReal.kappa} /\
          Oi.j_{2} = Analysis1.j /\ valid_sk Oi.sk{2} /\
          (Oi.countS <= Oi.i_ => (!Oij_LE.i_done /\ !Oi.j_end /\ Oi.sk \notin ROsk.RO.m)){2} /\
          (Oi.j_end => exists st, ROsk.RO.m.[Oi.sk] = Some (Oi.w_{1}, st)){2}).
  + by sim />.
  + proc; sp; if => //; wp; if => //; 2: if => //; last first.
    + by conseq (: ={r, RO.m}); [smt() | sim].
    + by conseq (: ={r, RO.m}); [smt() | sim].
    inline Oij_bad.sign_i Oij_LE(ROsk.RO).sign_i.
    rcondt{2} ^if; 1: auto => /> /#.
    wp; while (={RO.m, m0, oz, w, c, j, Oi.sk, OReal.kappa}).
    + by inline *; auto.
    wp; seq 7 7 :
     (={RO.m, m0, oz, w, c, j, Oi.sk, Oi.j_end, Oi.j_, Oi.logh, Oi.countH, Oi.countS, Oi.sk, Oi.i_, OReal.kappa} /\
     Oi.j_{2} = Analysis1.j /\ valid_sk Oi.sk{2} /\
     (!Oi.j_end /\  Oi.sk \notin ROsk.RO.m /\ Oi.countS = Oi.i_){2}).
    + conseq (: ={RO.m, m0, oz, w, c, j, Oi.sk, Oi.j_end, Oi.j_, Oi.logh, Oi.countH, Oi.countS, Oi.sk, Oi.i_}); 1: smt().
      wp; while (={RO.m, m0, oz, w, c, j, Oi.sk} /\  Oi.j_{1} = Analysis1.j); last by auto.
      by conseq (: ={RO.m, oz, w, c, j}) => />; sim.
    if=> //; 2: auto => /> /#.
    by inline *; rcondt{2} ^if; auto => />; smt(get_setE).
  by inline *; auto => /> *; rewrite mem_empty /= /#.
qed.

local lemma DRO_DLRO &m : 
  Pr[D(ROsk.RO).distinguish(kappa_, i, j) @ &m : res] = 
  Pr[D(ROsk.LRO).distinguish(kappa_, i, j) @ &m : res].
proof. byequiv (ROsk.FullEager.RO_LRO_D D commit_ll) => //. qed.

(* MOVE this to EC *)
lemma mu_dlet_le (d : 'a distr) (F1 : 'a -> 'b distr) (F2 : 'a -> 'c distr) P1 P2 :
  (forall x, mu (F1 x) P1 <= mu (F2 x) P2) => 
  mu (dlet d F1) P1 <= mu (dlet d F2) P2.
proof.
  rewrite !dletE => h; apply ler_sum_pos => /=; 1: smt(mu_bounded).
  by apply (summable_le_pos _ (mu1 d)); [ apply summable_mu1 | smt(mu_bounded)].
qed.

local lemma phr_j_end:
  phoare [D(ROsk.LRO).distinguish1 : kappa_ = Analysis1.kappa_ /\ i_i = i /\ j_i = j ==> Oi.j_end ] <= (p ^ Analysis1.j).
proof. 
  conseq (: Oi.j_end /\ b2i (Oij_LE.i_done) <= 1); 1: smt(). 
  bypr => &m *.
  fel 6 (b2i (Oij_LE.i_done)) (fun _ => p ^ j) 1 Oi.j_end
      [Oij_LE(ROsk.LRO).sign_i : (!Oij_LE.i_done /\ valid_sk Oi.sk)]
      true => //.
  + by have /= -> := big_int1 0.
  + by inline *; auto.
  + proc; rcondt^if => //.
    seq 6 : (oz = None) (p^Analysis1.j) 1%r _ 0%r (!Oi.j_end) => //.
    + by conseq /> => //.
    + sp; wp; conseq (: _ : <= (if oz = None then p ^ (Analysis1.j - j) else 0%r)) => //.
      while (j <= Analysis1.j /\ valid_sk Oi.sk).
      + move=> hw; exlim j => j0.
        conseq (: _ : <= (if oz = None then p ^ (Analysis1.j - j0) else 0%r)) => //.
        seq 2 : (oz = None) p (p^(Analysis1.j - (j0 + 1))) _ 0%r (j = j0 + 1 /\ j <= Analysis1.j /\ valid_sk Oi.sk).
        + by wp; conseq (:true) => // /#.
        + wp; inline *; wp 4.
          rndsem 1.
          rnd (fun (wscoz: _ * _ * _ * _) => wscoz.`4 = None).
          auto => |> &hr _ hv _; apply (RealOrder.ler_trans _ _ _ _ (p_def Oi.sk{hr} hv)).
          apply mu_dlet_le => w_st /=; apply mu_dlet_le => c.
          by rewrite dunitE dunit1E.
        + by conseq hw => />. 
        + by conseq hw => /#.
        move=> /> *; rewrite -RField.exprS /#. 
      by auto => />; smt (RField.expr0 j_bounded).
    by rcondf^if; 1: auto => />; conseq />.
  + move=> c; proc; rcondt^if => //; wp.
    by conseq (:true) => />; auto.
  by move=> b c; proc; rcondf^if => //.
qed.

local lemma Pr_DLRO &m : Pr[D(ROsk.LRO).distinguish(kappa_, i, j) @ &m : res] <= p^j * (qh%r * eps).
proof.
  (* the eps should be easy the difficult par is p^j *)
  byphoare ( : kappa_ = Analysis1.kappa_ /\ i_i = i /\ j_i = j ==> res) => //; proc.
  seq 1 : Oi.j_end (p ^ j) (qh%r * eps) _ 0%r (Oi.sk \notin ROsk.RO.m /\ size Oi.logh <= qh /\ valid_sk Oi.sk) => //;
    last by conseq (:false) => />.  
  + inline D(ROsk.LRO).distinguish1.
    call (: Oi.sk \notin ROsk.RO.m /\ size Oi.logh <= Oi.countH <= qh /\ valid_sk Oi.sk).
    + by proc; sp; if => //; wp; conseq (:true) => // /#. 
    + by conseq />.
    inline *; auto => />; smt(qh_ge0 mem_empty).  
  (* [ : Oi.j_end ] <= p ^ j *)
  + call (phr_j_end); auto => />.
  (* [w_ <@ dfst (commit sk) : w_ \in logh ] *)
  inline *; rcondt ^if; 1: by auto.
  wp; rnd (fun x => fst x \in Oi.logh); auto => |> &hr _ hsize hval _; split; 2: smt(get_setE).
  have := mu_mem_le_mu1 (dfst (commit Oi.sk{hr})) Oi.logh{hr} eps (valid_sk_mu1_commit Oi.sk{hr} hval).
  rewrite /dfst dmapE /(\o); smt (eps_ge0 size_ge0).
qed.

lemma concl_j &m: 
  Pr[Hij(Adv, Oij).main(kappa_, i, j+1) @ &m : res] - Pr[Hij(Adv, Oij).main(kappa_, i, j) @ &m : res] <=  p^j * (qh%r*eps).
proof.
  have := bad &m; have := Oij_split_Oij_bad &m; have := Pr_DLRO &m.
  rewrite (Oij_Oij_split &m) (Oij_bad_DRO &m) (DRO_DLRO &m) /#.
qed.

end section J.

lemma concl_i &m : 
  Pr[Hi(Adv, Oi).main(kappa_, i+1) @ &m : res] - Pr[Hi(Adv, Oi).main(kappa_, i) @ &m : res] <=
    (qh%r * eps) / (1%r - p).
proof.
  apply (RealOrder.ler_trans (bigi predT (fun (j : int) =>  p^j * (qh%r * eps)) 0 kappa_)).
  + rewrite (HiHi1 &m); apply StdBigop.Bigreal.ler_sum_seq => j /mem_range hj _ /=.
    by apply concl_j.
  rewrite -mulr_suml; have := sum_pow_le p kappa_ _ _; smt(kappa_gt0 p_bounded qh_ge0 eps_ge0).
qed.

end section I.

lemma GSet_GSet1 &m: 
  Pr[Game_k(Adv, CountBound(OSet)).main(kappa_) @ &m : res] - 
  Pr[Game_k(Adv, CountBound(OSet1)).main(kappa_) @ &m : res] <= 
     qs%r * (qh%r * eps) / (1%r - p).
proof.
  apply (RealOrder.ler_trans (bigi predT (fun (j : int) =>  (qh%r * eps)/(1%r - p)) 0 qs)).
  rewrite GSet_GSet1_aux; apply StdBigop.Bigreal.ler_sum_seq => i /mem_range hi _ /=.
  apply (concl_i i hi).
  rewrite StdBigop.Bigreal.sumri_const 1:qs_ge0 //.
qed.

(* ---------------------------------------------------------------- *)
(* Now we go back to an infinity number of loop iteration           *)
(* This allows to remove the dependency to kappa_                   *)

local module OSet1B1 : Oracle_i = {
  import var OReal
  include var OSet[init, h]
  var bad : bool

  proc sign(m: M) = {
    var w, st, c, oz, i;

    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;

    i <- 0;
    oz <- None;
    while(oz = None /\ i < OReal.kappa) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
      i <- i + 1;
    }
    if (oz = None) { 
       bad <- true;
    }
    if(oz <> None) RO.set((w, m), c);
    return if oz <> None then Some (w, c, oget oz) else None;
  }
}.

local module OSet1B2 : Oracle_i = {
  import var OReal
  include var OSet[init, h]

  proc sign(m: M) = {
    var w, st, c, oz, i;

    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;

    i <- 0;
    oz <- None;
    while(oz = None /\ i < OReal.kappa) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
      i <- i + 1;
    }
    if (oz = None) { 
      OSet1B1.bad <- true;
      while(oz = None) {
        (w, st) <$ commit sk;
        c <$ dC;
        oz <- respond sk st c;
      }
    }
    if(oz <> None) RO.set((w, m), c);
    return if oz <> None then Some (w, c, oget oz) else None;
  }
}.

local module OSet1_inf_i : Oracle_i = { 
  import var OReal
  include var OSet[init, h]

  proc sign(m: M) = {
    var w, st, c, oz, i;

    (* Silences unused variables warning *)
    w <- witness;
    c <- witness;

    i <- 0;
    oz <- None;
    while(oz = None) {
      (w, st) <$ commit sk;
      c <$ dC;
      oz <- respond sk st c;
      i <- i + 1;
    }
    RO.set((w, m), c);
    return Some (w, c, oget oz);
  }
}.

local module Game_kb(O:Oracle_i) = { 
  proc main (kappa_:int) = { 
    var b;
    OSet1B1.bad <- false;
    b <@ Game_k(Adv, CountBound(O)).main(kappa_);
    return b;
  }
}.
  
local lemma Set1_Set1B1 &m : 
  Pr[Game_k(Adv, CountBound(OSet1)).main(kappa_) @ &m : res] =
  Pr[Game_kb(OSet1B1).main(kappa_) @ &m : res].
proof. byequiv => //; proc; inline *; sim. qed.

local lemma Set1B1_Set1B2 &m: 
  Pr[Game_kb(OSet1B1).main(kappa_) @ &m : res] <= 
   Pr[Game_kb(OSet1B2).main(kappa_) @ &m : res] + Pr[Game_kb(OSet1B1).main(kappa_) @ &m : OSet1B1.bad].
proof. byupto. qed.

local lemma Set1B2_Set1_inf_i &m : 
  Pr[Game_kb(OSet1B2).main(kappa_) @ &m : res] =
  Pr[Game(Adv, CountBound(OSet1_inf_i)).main() @ &m : res].
proof.
  byequiv=> //; proc; inline *; wp.
  call (: ={RO.m, OReal.sk, Count.countH, Count.countS} /\ OReal.kappa{1} = Analysis1.kappa_); last by auto.
  + by sim />.
  proc; sp; if => //.
  inline OSet1B2.sign OSet1_inf_i.sign.
  splitwhile{2} ^while  : (i < kappa_).
  seq 6 6 : (={ m, w, c, i, oz, RO.m, OReal.sk, Count.countH, Count.countS} /\ OReal.kappa{1} = Analysis1.kappa_).
  + while (={ m, w, c, i, oz, OReal.sk} /\ OReal.kappa{1} = Analysis1.kappa_); 2: by auto.
    by conseq (: ={w, c, i, oz}) => //; sim.
  inline RO.set; if{1}.
  + by wp; while (={ m, w, c, oz, OReal.sk}); [ sim | auto => />].
  rcondf{2} ^while; 1: by auto.
  by rcondt{1} ^if; auto => />. 
qed.

local lemma Set1_i_Set1_inf &m : 
   Pr[Game(Adv, CountBound(OSet1_inf_i)).main() @ &m : res] = 
   Pr[Game(Adv, CountBound(OSet1_inf)).main() @ &m : res].
proof. byequiv => //; sim. qed.

local lemma Pr_bad &m : Pr[Game_kb(OSet1B1).main(kappa_) @ &m : OSet1B1.bad] <= qs%r * p^kappa_.
proof.
  byehoare (: (kappa_ = Analysis1.kappa_) `|` (qs%r * p ^ kappa_)%xr  ==> _)=> //; proc. 
  inline Game_k(Adv, CountBound(OSet1B1)).main Game(Adv, CountBound(OSet1B1)).main; wp.
  call /(fun x => x) (: (valid_sk OReal.sk /\ OReal.kappa = Analysis1.kappa_) `|` (OSet1B1.bad%xr + (qs - Count.countS)%xr * (p^kappa_)%xr)). 
  + by move=> &hr; apply xle_cxr_r => /> /#.
  + by conseq /(fun x =>  (valid_sk OReal.sk /\ OReal.kappa = kappa_) `|` (OSet1B1.bad%xr + (qs - Count.countS)%xr * (p ^ kappa_)%xr))
          (: 0%xr ==> 0%xr).
  + proc; seq 1 : #pre; 1: auto; if; 2: by auto => &hr; apply xle_cxr => />.
    inline *; wp => /=.
    seq 5 : ((i = 0 /\ oz = None) `|` #pre); 1: by auto.
    conseq /(fun x => (valid_sk OReal.sk /\ OReal.kappa = kappa_) `|`
             (x + OSet1B1.bad%xr + (qs - (Count.countS + 1))%xr * (p ^ kappa_)%xr)) 
          (: (valid_sk OReal.sk /\ OReal.kappa = kappa_ /\ i = 0) `|` 
               ((oz = None)%xr * (p^kappa_)%xr) ==> (oz = None)%xr).
    + by auto => &hr /=; apply xle_cxr => |> * /#.
    + by auto => &hr /=; case: (oz{hr} = None) => ?; apply xle_cxr => |> /#. 
    while ((valid_sk OReal.sk /\ OReal.kappa = kappa_ /\ i <= kappa_) `|` 
             ((oz = None)%xr * (p^(kappa_ - i))%xr)).
    + by move=> &hr /=; apply xle_cxr_r => |>; smt(RField.expr0).
    + wp 3 => /=.
      conseq /(fun x =>  (valid_sk OReal.sk /\ OReal.kappa = kappa_ /\ i + 1 <= kappa_) `|`
                (x * (p ^ (kappa_ - (i + 1)))%xr))
             (: valid_sk OReal.sk `|` p%xr ==> (oz=None)%xr) => //.
      + move=> &hr /=; apply xle_cxr => |> *; split; 1: smt().
        rewrite !to_pos_pos; 1..3: smt(p_bounded expr_ge0).      
        case: (p = 0%r) => [-> /= | ?].
        + by rewrite !RField.expr0z; case (kappa_ - i{hr} = 0).
        by rewrite -{1}(RField.expr1 p) -RField.exprD; smt(p_bounded).
      auto => &hr; apply xle_cxr_r => *; rewrite Ep_commit_dc_None /=.
      rewrite to_pos_pos;1: smt(p_bounded).
      by apply p_def.
    by auto => &hr /=; apply xle_cxr => |> *; apply kappa_ge0.
  inline *; auto => &hr; rewrite Ep_cxr /= EpC keygen_ll.
  apply xle_cxr => />.
  rewrite !to_pos_pos /=; smt(qs_ge0 expr_ge0 p_bounded).
qed.

lemma GReal_GSet_inf &m : 
  Pr[Game(Adv, Count(OReal)).main() @ &m : res] <=
    (2%r * qs%r) * p^kappa_ + (Pr[Game(Adv, CountBound(OSet1_inf)).main() @ &m : res] +
    qs%r * (qh%r * eps) / (1%r - p) + 
    qs%r * eps * ((qs%r + 1.0)/ (2.0 * (1.0 - p)^2) + qh%r / (1.0 - p))).
proof.
  apply (ler_trans ( Pr[Game(Adv, CountBound(OSet1_inf)).main() @ &m : res] + qs%r * p^kappa_ +
    qs%r * (qh%r * eps) / (1%r - p) + 
    (qs%r * p^kappa_ + (qs%r * eps * ((qs%r + 1.0)/ (2.0 * (1.0 - p)^2) + qh%r / (1.0 - p)))))); last smt().
  apply (ler_trans _ _ _ (GReal_GSet Adv A_bound kappa_ &m kappa_gt0)).
  apply ler_add2r.
  apply (ler_trans (Pr[Game_k(Adv, CountBound(OSet1)).main(kappa_) @ &m : res] + qs%r * (qh%r * eps) / (1%r - p))).
  + move: (GSet_GSet1 &m) => /#.
  apply ler_add2r; move: (Set1B1_Set1B2 &m) (Pr_bad &m).
  rewrite Set1_Set1B1 Set1B2_Set1_inf_i Set1_i_Set1_inf /#. 
qed.

end section Analysis.

end Analysis1.

(* To remove the dependency to Oi *)
section.

declare module Adv <: Adversary {-Count, -RO, -OReal}.

declare axiom A_ll : forall (O <: Oracle{-Adv}),
  islossless O.h =>
  islossless O.sign =>
  islossless Adv(O).distinguish.

declare axiom A_bound : forall (O <: Oracle_i{-Adv, -Count}), 
  hoare [ Adv(Count(O)).distinguish : Count.countS = 0 /\ Count.countH = 0 ==> 
                                      Count.countS <= qs /\ Count.countH <= qh ].

local clone import Analysis1 as A.

lemma GReal_GSet_inf &m :  
  Pr[Game(Adv, Count(OReal)).main() @ &m : res] <= 
   Pr[Game(Adv, CountBound(OSet1_inf)).main() @ &m : res] + 
    2%r * qs%r * qh%r * eps / (1%r - p) + 
    qs%r * eps * (qs%r + 1.0) / (2.0 * (1.0 - p)^2).
proof.
  have hp : -1%r < p < 1%r by smt(p_bounded).
  apply (ler_trans (Pr[Game(Adv, CountBound(OSet1_inf)).main() @ &m : res] + 
                        qs%r * (qh%r * eps) / (1%r - p) + 
                        qs%r * eps * ((qs%r + 1.0)/ (2.0 * (1.0 - p)^2) + qh%r / (1.0 - p))));
   last by apply lerr_eq; ring.
  have hc : RealSeq.converge (fun (x : int) => 2%r * qs%r * p ^ x).
  + by apply/cnvZ/cnv_pow/hp. 
  apply (ler_trans (lim (fun kappa => 
           (2%r * qs%r) * p^kappa + (Pr[Game(Adv, CountBound(OSet1_inf)).main() @ &m : res] + 
           qs%r * (qh%r * eps) / (1%r - p) + 
           qs%r * eps * ((qs%r + 1.0)/ (2.0 * (1.0 - p)^2) + qh%r / (1.0 - p)))))).
  + apply (geC_lim_from 1) => /=.
    + by move=> kappa_ hk; apply (A.GReal_GSet_inf Adv A_bound A_ll kappa_ _ &m) => /#. 
    apply cnvD => //; apply cnvC.
  by rewrite limD 1:// 1:cnvC limZ lim_pow //= limC.
qed.

end section.
