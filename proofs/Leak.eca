require import AllCore List.
require QDigitalSignaturesRO.

type leak_t.

clone import QDigitalSignaturesRO as Sig.
clone import Sig.Stateless.

(* Scheme providing a leaking signature function and a leagage simulator *)
module type SchemeL = { 
  include Scheme
  proc signL (sk : sk_t, m : msg_t): sig_t * leak_t
  proc leakage (pk : pk_t, m : msg_t, sig : sig_t): leak_t
}.

(* Generic oracle type providing access to a leaking signature oracle
(incl. initialization and auxilary functions) *)
module type Oracle_LEAK = { 
  proc init (pki : pk_t, ski : sk_t) : unit
  proc signL (m : msg_t) : sig_t * leak_t
  proc fresh(m : msg_t) : bool {}
  proc nr_queries() : int {}
}.

(* Leaking signature oracle (w/o auxiliary functions *)
module type SOracle_LEAK = { 
  proc signL (m : msg_t) : sig_t * leak_t
}.

module type Adv_LEAK (O : SOracle_LEAK) = { 
  proc guess (pk : pk_t) : bool 
}.

(* Implementation using the real leagage *)
module O_LEAK_real(S : SchemeL) : Oracle_LEAK = {
  include var BaseOracle
  var sk : sk_t
  var pk : pk_t (* not used, but allows sharing init with O_LEAK_sim *)

  proc init (pki : pk_t, ski : sk_t) = { pk <- pki; sk <- ski; qs <- []; }

  proc signL (m : msg_t) = { 
    var r; 
    r <@ S.signL(sk,m);
    qs <- rcons qs m;
    return r;
  } 
}.

(* Implementation using simulated leagage *)
module O_LEAK_sim(S : SchemeL) = {
  include var O_LEAK_real(S) [-signL]

  proc signL (m : msg_t) = { 
    var s, l; 
    s <@ S.sign(sk,m);
    l <@ S.leakage(pk,m,s);
    BaseOracle.qs <- rcons BaseOracle.qs m;
    return (s,l);
  } 
}.

(* Leakage game: Adversary wins if he can distinguish between real
leakage and simulated leakage *)

module LEAK (S : SchemeL, A : Adv_LEAK , O : Oracle_LEAK) = { 
  var m : msg_t list

  proc main() = { 
    var pk, sk, b;
    (pk,sk) <@ S.keygen();
    O.init(pk,sk);
    b <@ A(O).guess(pk);
    return b;
  }
}.

module LEAK_real (S: SchemeL, A : Adv_LEAK) = LEAK (S,A,O_LEAK_real(S)).
module LEAK_sim  (S: SchemeL, A : Adv_LEAK) = LEAK (S,A,O_LEAK_sim(S)).

(* CT-EF-CMA game - same as the EF-CMA game, but the adversary is
given access to a signing oracle that also provides some leagage *)

module type Adv_CT_EFCMA(O : SOracle_LEAK) = {
  proc forge(pk : pk_t) : msg_t * sig_t
}.

module CT_EF_CMA_(S : SchemeL, A : Adv_CT_EFCMA, O : Oracle_LEAK) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var m : msg_t;
    var sig : sig_t;
    var nrqs : int;
    var is_valid, is_fresh : bool;
    
    (pk, sk) <@ S.keygen();
    O.init(pk, sk);

    (*
      Ask the adversary to forge a signature for any message (and provide both the
      message and the signature) given the public key pk and access to a signing oracle 
      that it can query at most q_efcma times
    *)
    (m, sig) <@ A(O).forge(pk);

    is_valid <@ S.verify(pk, m, sig);
    is_fresh <@ O.fresh(m);
    nrqs <@ O.nr_queries();
        
    (* 
      Success iff
      (1) "nrqs <= q_efcma": the adversary made at most q_efcma oracle queries, and
      (2) "is_valid": the forged signature provided by the adversary is valid, and
      (3) "is_fresh": the message for which the adversary forged a signature is fresh.
    *)
    return nrqs <= q_efcma /\ is_valid /\ is_fresh; 
  }
}.

module CT_EF_CMA(S : SchemeL, A : Adv_CT_EFCMA) = CT_EF_CMA_(S,A,O_LEAK_real(S)).

module (Red_EFCMA (S : SchemeL, A : Adv_CT_EFCMA) : Adv_EFCMA) (O : SOracle_CMA) = { 
  var pk : pk_t 

  module Ol : SOracle_LEAK = { 
    proc signL (m : msg_t) = { 
      var sig,leak;
      
      sig <@ O.sign(m);
      leak <@ S.leakage(pk,m,sig);
      return (sig,leak);
    }
  }

  proc forge (pki) = { 
    var r;
    pk <- pki;
    r <@ A(Ol).forge(pk);
    return r;
  } 
}.

module (Red_LEAK (S : SchemeL, A : Adv_CT_EFCMA) : Adv_LEAK) (O : SOracle_LEAK) = { 
  var qs : msg_t list

  module O' = {
    proc signL (m : msg_t) = { 
      var r; 

      qs <- rcons qs m;
      r <@ O.signL(m);
      return r;
    }
  }

  proc guess(pki : pk_t) = {
    var m, sig, is_valid; 
    qs <- [];
    (m,sig) <@ A(O').forge(pki);
    is_valid <@ S.verify(pki,m,sig);
    return size qs <= q_efcma /\ is_valid /\ !(m \in qs);
  }
}.

section PROOF.

declare module S <: SchemeL{-Red_LEAK,-Red_EFCMA, -O_LEAK_sim,-O_CMA_Default}.
declare module A <: Adv_CT_EFCMA{-S,-Red_LEAK,-Red_EFCMA, -O_LEAK_sim,-O_CMA_Default}.

lemma ct_of_leak &m : 
  Pr [ CT_EF_CMA(S,A).main() @ &m : res ] <= 
  Pr [ EF_CMA(S,Red_EFCMA(S,A),O_CMA_Default).main() @ &m : res ] + 
  `| Pr [ LEAK_real(S,Red_LEAK(S,A)).main() @ &m : res ] - 
     Pr [ LEAK_sim(S,Red_LEAK(S,A)).main()  @ &m : res ] |.
proof.
have -> : Pr [ CT_EF_CMA(S,A).main() @ &m : res ] = 
          Pr [ LEAK_real(S,Red_LEAK(S,A)).main() @ &m : res ].
- byequiv => //; proc; inline*; wp. 
  call(: true).
  call(: ={glob O_LEAK_real, glob BaseOracle, glob S} /\ (Red_LEAK.qs = BaseOracle.qs){2} ). 
  + by proc; inline*; wp; call(: true); auto => />. 
  by auto; call(: true) => />.
suff: Pr[LEAK_sim(S, Red_LEAK(S, A)).main() @ &m : res] = 
      Pr[EF_CMA(S, Red_EFCMA(S, A), O_CMA_Default).main() @ &m : res] by smt().
byequiv => //; proc; inline*; wp; call(: true); wp.
call(: ={glob S, glob BaseOracle} 
       /\ ={sk}(O_LEAK_real,O_CMA_Default)
       /\ (Red_LEAK.qs = BaseOracle.qs){1} 
       /\ O_LEAK_real.pk{1} = Red_EFCMA.pk{2}). 
- by proc; inline*; wp; call(: true); wp; call(: true); auto => />. 
by auto; call(:true) => />.
qed.

end section PROOF.
